     1                                  [map all ./Listings/edlin.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  ;EDLIN, an absolute last resort file editor.
     5                                  ;
     6                                  ;                       !!DONT FORGET!!
     7                                  ;       Each line is terminated first with 0Dh then 0Ah (CR,LF)
     8                                  ;                       !!DONT FORGET!!
     9                                  ;
    10                                  
    11                                  ;Edlin will always produce a backup file and refuses to open files 
    12                                  ; with .BAK extension (backup files)
    13                                  
    14                                  ;Edlin will erase the previous backup if one exists, ensuring there
    15                                  ; is enough free space for a new copy of the backup.
    16                                  ;It then creates a new file with the filename with a $$$ extension.
    17                                  ;All edits occur in memory and are flushed to it. We then rename it
    18                                  ; to the desired filename.
    19                                  ;BAK files cannot be opened.
    20                                  ;
    21                                  ;Empty lines are default just a CR,LF pair
    22                                  
    23                                  ;Edlin has two modes of operation: Command and Edit
    24                                  
    25                                  %include "./Include/dosMacro.mac"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------------------------------
     3                              <1> ;Generic Macros file
     4                              <1> ;The following instruction extensions allow to conditionally return
     5                              <1> ;The idea was borrowed from the DOS Source Code
     6                              <1> ;
     7                              <1> ;-------------------------------------------------------------------------------
     8                              <1> 
     9                              <1> ;-------------------------------------------------------------------------------
    10                              <1> ;These macros are live and must not be touched
    11                              <1> ;-------------------------------------------------------------------------------
    12                              <1> %macro return 0
    13                              <1> %%_ret:
    14                              <1>     ret
    15                              <1> %assign retOff %%_ret-$$  ;Get offset into segment of %%_ret
    16                              <1> %endmacro
    17                              <1> 
    18                              <1> %macro cret 1
    19                              <1> %%_base:
    20                              <1> %assign baseVar %%_base-$$ ;Get offset into segment of %%_base
    21                              <1>     %ifdef retOff
    22                              <1>     %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <1>     %ifdef currSegVBase
    24                              <1>     j%+1 short (retOff+currSegVBase)
    25                              <1>     %else
    26                              <1>     j%+1 short retOff
    27                              <1>     %endif  ;End ifdef currSegVBase
    28                              <1>     %else 
    29                              <1>     j%-1 short %%a
    30                              <1>     return
    31                              <1> %%a:
    32                              <1>     %endif  ;End the distance measurement if
    33                              <1>     %else   
    34                              <1>     j%-1 short %%a
    35                              <1>     return
    36                              <1> %%a:
    37                              <1>     %endif  ;End ifdef retoff
    38                              <1> %endmacro
    39                              <1> 
    40                              <1> %macro retz 0
    41                              <1> cret z
    42                              <1> %endmacro
    43                              <1> 
    44                              <1> %macro retnz 0
    45                              <1> cret nz
    46                              <1> %endmacro
    47                              <1> 
    48                              <1> %macro rete 0
    49                              <1> cret e
    50                              <1> %endmacro
    51                              <1> 
    52                              <1> %macro retne 0
    53                              <1> cret ne
    54                              <1> %endmacro
    55                              <1> 
    56                              <1> %macro retc 0
    57                              <1> cret c
    58                              <1> %endmacro
    59                              <1> 
    60                              <1> %macro retnc 0
    61                              <1> cret nc
    62                              <1> %endmacro
    63                              <1> 
    64                              <1> %macro retb 0
    65                              <1> cret b
    66                              <1> %endmacro
    67                              <1> 
    68                              <1> %macro retnb 0
    69                              <1> cret nb
    70                              <1> %endmacro
    71                              <1> 
    72                              <1> %macro reta 0
    73                              <1> cret a
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> %macro retna 0
    77                              <1> cret na
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro breakpoint 0
    81                              <1> xchg bx, bx
    82                              <1> %endmacro
    26                                  %include "./Include/dosError.inc"
     1                              <1> ;DOS Error codes
     2                              <1> 
     3                              <1> ;Extended Error Codes
     4                              <1> errInvFnc   equ 1   ;Invalid function number
     5                              <1> errFnf      equ 2   ;File not found
     6                              <1> errPnf      equ 3   ;Path not found
     7                              <1> errNhl      equ 4   ;Too many open handles, no handles left
     8                              <1> errAccDen   equ 5   ;Access denied (to resource)
     9                              <1> errBadHdl   equ 6   ;Invalid handle
    10                              <1> errMCBbad   equ 7   ;MCB's destroyed
    11                              <1> errNoMem    equ 8   ;Insufficient memory
    12                              <1> errMemAddr  equ 9   ;Invalid Memory Block Address
    13                              <1> errBadEnv   equ 10  ;Invalid environment
    14                              <1> errBadFmt   equ 11  ;Invalid format (path etc)
    15                              <1> errAccCde   equ 12  ;Invalid Access Code    ?
    16                              <1> errInvDat   equ 13  ;Invalid data
    17                              <1> ;           equ 14  ;Reserved
    18                              <1> errBadDrv   equ 15  ;Invalid drive specified
    19                              <1> errDelCD    equ 16  ;Attempt to delete the current directory
    20                              <1> errDevUnk   equ 17  ;Not the same device (Device Unknown)
    21                              <1> errNoFil    equ 18  ;No more files, no match found
    22                              <1> ;The following are Driver error codes + 19
    23                              <1> drvErrShft  equ 19  ;Used to shift Driver error codes to extended error codes
    24                              <1> errWpd      equ 19  ;Attempt to write on write protected disk
    25                              <1> errUnkUnt   equ 20  ;Unknown Unit
    26                              <1> errDrvNR    equ 21  ;Drive not ready
    27                              <1> errUnkCmd   equ 22  ;Unknown Command
    28                              <1> errCRCerr   equ 23  ;Data (CRC) error
    29                              <1> errBadRLn   equ 24  ;Bad request structure length
    30                              <1> errSekErr   equ 25  ;Seek error
    31                              <1> errUnkMed   equ 26  ;Unknown media type
    32                              <1> errSecNF    equ 27  ;Sector not Found
    33                              <1> errNoPap    equ 28  ;Printer out of paper
    34                              <1> errWF       equ 29  ;Write fault
    35                              <1> errRF       equ 30  ;Read fault
    36                              <1> errGF       equ 31  ;General fault
    37                              <1> ;----------------------------------------------
    38                              <1> ;The following two go inbetween the Disk errors
    39                              <1> errShrVio   equ 32  ;Sharing violations
    40                              <1> errLokVio   equ 33  ;File Lock violation
    41                              <1> ;----------------------------------------------
    42                              <1> errIDC      equ 34  ;Driver code, Invalid Disk Change
    43                              <1> errNoFCB    equ 35  ;FCB unavailable
    44                              <1> errShrFul   equ 36  ;Sharing buffer full
    45                              <1> 
    46                              <1> errNoNet    equ 50  ;Network request not supported, generic net fail
    47                              <1> 
    48                              <1> errFilExist equ 80  ;File already exists
    49                              <1> errDirExist equ 82  ;Directory already exists
    50                              <1> errFI44     equ 83  ;Fail on INT 44h
    51                              <1> errRedir    equ 84  ;Too many levels of redirection
    52                              <1> errDupRedir equ 85  ;Trying to redirect a redirection
    53                              <1> errBadPass  equ 86  ;Bad password
    54                              <1> errBadParam equ 87  ;Bad parameter passed to request
    55                              <1> errNetWrite equ 88  ;Network Write Fault
    56                              <1> ;-----------------------------------------------------------------------------
    57                              <1> ;Error Loci
    58                              <1> eLocUnk     equ 1   ;Unknown locus, nonspecific or not appropriate
    59                              <1> eLocDsk     equ 2   ;Disk, related to Random Access to a disk or block device
    60                              <1> eLocNet     equ 3   ;Network related issues, shouldnt affect us (yet!)
    61                              <1> eLocChr     equ 4   ;Serial/Character Device error
    62                              <1> eLocMem     equ 5   ;Related to RAM
    63                              <1> ;-----------------------------------------------------------------------------
    64                              <1> ;Error Actions
    65                              <1> eActRet     equ 1   ;Retry
    66                              <1> eActDRet    equ 2   ;Delay then retry (Try again later)
    67                              <1> eActUsr     equ 3   ;Ask user to re-input data, i.e. bad filename or something
    68                              <1> eActAbt     equ 4   ;Abort with cleanup
    69                              <1> eActKil     equ 5   ;Abort without cleanup
    70                              <1> eActIgn     equ 6   ;Ignore error
    71                              <1> eActRetUsr  equ 7   ;Retry after user intervention (i.e swap remdev)
    72                              <1> ;-----------------------------------------------------------------------------
    73                              <1> ;Error classes
    74                              <1> eClsOoR     equ 1   ;Out of resources, no mem or handles
    75                              <1> eClsTS      equ 2   ;Temp sitch, should go away
    76                              <1> eClsAuth    equ 3   ;Authorisation, e.g. file permission error 
    77                              <1> eClsInt     equ 4   ;Internal DOS error or bug
    78                              <1> eClsHrdFlt  equ 5   ;Hardware Failure
    79                              <1> eClsSysFlt  equ 6   ;System Failure, i.e. missing or bad cfg files
    80                              <1> eClsAppFlt  equ 7   ;Application Program error, inconsistent requests etc...
    81                              <1> eClsNotFnd  equ 8   ;Resource not found (such as free SFT entry etc...)
    82                              <1> eClsBadFmt  equ 9   ;Bad format for resource
    83                              <1> eClsLocked  equ 10  ;Resource Locked
    84                              <1> eClsMedia   equ 11  ;Error is on medium, i.e. wrong or damaged remdev
    85                              <1> eClsClash   equ 12  ;Resource already exists!
    86                              <1> eClsUnk     equ 13  ;Unknown class
    27                                  %include "./Include/edStruc.inc"
     1                              <1> ;edlin structures
     2                              <1> lineLen     equ 253
     3                              <1> halflineLen equ 128
     4                              <1> maxLine     equ 65529
     5                              <1> maxAlloc    equ maxLine*lineLen
     6                              <1> maxParas    equ (maxAlloc >> 4) + 1
     7                              <1> fileRO      equ 1   ;Mask for Read Only
     8                              <1> fileDir     equ 10h ;Mask for Directory
     9                              <1> 
    10                              <1> ;Bona-Fida Structures
    11                              <1> 
    12                              <1> struc line
    13 00000000 ??                  <1>     .bBufLen    db ?    ;Buffer size (255)
    14 00000001 ??                  <1>     .bStrLen    db ?    ;Length of the string entered in buffer
    15 00000002 <res FDh>           <1>     .pString    db lineLen dup (?)      ;Actual string itself
    16                              <1> endstruc
    17                              <1> 
    18                              <1> struc halfLine
    19 00000000 ??                  <1>     .bBufLen    db ?    ;Buffer size (130)
    20 00000001 ??                  <1>     .bStrLen    db ?    ;Length of the string entered in buffer
    21 00000002 <res 80h>           <1>     .pString    db halflineLen dup (?)   ;Actual string itself
    22                              <1> endstruc
    23                              <1> 
    24                              <1> struc filename
    25                              <1> ;8.3 File name struct
    26 00000000 ????????????????    <1>     .fName  resb 8
    27 00000008 ??????              <1>     .fExt   resb 3
    28                              <1> endstruc
    28                                  %include "./Include/dosStruc.inc"
     1                              <1> ;Structures and equates coming from DOS
     2                              <1> 
     3                              <1> ;MISC ASCII control chars
     4                              <1> NUL equ 00h ;^@         | ASCII Null
     5                              <1> ETX equ 03h ;^C         | ASCII Break (End of Text)
     6                              <1> ACK equ 06h ;^F         | ASCII Acknowledgement
     7                              <1> BEL equ 07h ;^G         | ASCII Bell
     8                              <1> BSP equ 08h ;^H         | ASCII Backspace
     9                              <1> TAB equ 09h ;^I         | ASCII Horizontal Tab
    10                              <1> LF  equ 0Ah ;^J         | ASCII Line Feed
    11                              <1> CR  equ 0Dh ;^M         | ASCII Carriage Return
    12                              <1> DLE equ 10h ;^P         | ASCII Data Link End (Toggle Print Echo)
    13                              <1> DC3 equ 13h ;^S         | ASCII Device Control 3 (Toggle Scroll Lock)
    14                              <1> DC4 equ 14h ;^T         | ASCII Device Control 4
    15                              <1> NAK equ 15h ;^U         | ASCII Negative Acknowledgement
    16                              <1> ETB equ 17h ;^W         | ASCII End of Transmission Block
    17                              <1> EOF equ 1Ah ;^Z         | ASCII Substitute character (End of File)
    18                              <1> ESC equ 1Bh ;           | ASCII Escape char, used for ANSI.SYS
    19                              <1> SPC equ 20h ;Printable  | ASCII Space
    20                              <1> ;This last one is NEVER printed with a caret as it is a console control char
    21                              <1> DEL equ 7Fh ;^?         | ASCII Rubout (Del char and dec cursor)
    22                              <1> 
    23                              <1> asciiCaret  equ 20h ;Used to check which chars need to be printed with caret
    24                              <1> ;Extended Ascii Codes
    25                              <1> eF1     equ 3Bh ;F1 second byte
    26                              <1> eF2     equ 3Ch ;F2 second byte
    27                              <1> eF3     equ 3Dh ;F3 second byte
    28                              <1> eF4     equ 3Eh ;F4 second byte
    29                              <1> eF5     equ 3Fh ;F5 second byte
    30                              <1> eF6     equ 40h ;F6 second byte
    31                              <1> eF7     equ 41h ;F7 second byte
    32                              <1> eCursL  equ 4Bh ;Cursor Left second byte
    33                              <1> eCursR  equ 4Dh ;Cursor Right second byte
    34                              <1> eIns    equ 52h ;Insert second byte
    35                              <1> eDel    equ 53h ;DEL second byte (not necessarily delete key)
    36                              <1> 
    37                              <1> ;Directory attribute equates
    38                              <1>     dirReadOnly     equ 01h
    39                              <1>     dirHidden       equ 02h
    40                              <1>     dirSystem       equ 04h
    41                              <1>     dirVolumeID     equ 08h
    42                              <1>     dirDirectory    equ 10h
    43                              <1>     dirArchive      equ 20h
    44                              <1>     dirCharDev      equ 40h ;Never written to disk, used to represent a Char Dev
    45                              <1>     dirLongName     equ dirReadOnly | dirHidden | dirSystem | dirVolumeID
    46                              <1>     ;If any of the three bits are set, then ALL three bits are set
    47                              <1>     ; in addition to whatever the user passed to search for.
    48                              <1>     dirInclusive    equ dirHidden | dirSystem | dirDirectory
    49                              <1>     dirIncFiles     equ dirHidden | dirSystem
    50                              <1> 
    51                              <1> struc cmdArgs   ;Ptr returned in rdx after 41h/6101h has this structure
    52 00000000 <res 10h>           <1>     .fcb1       db 16 dup (?)  ;First FCB,    argument 1
    53 00000010 <res 14h>           <1>     .fcb2       db 20 dup (?)  ;Second FCB,   argument 2
    54                              <1>     .dta:   ;Pointer to the default DTA in the
    55 00000024 ??                  <1>     .parmList   db ?   ;Number of characters in command tail
    56 00000025 <res 7Fh>           <1>     .progTail   db 127 dup (?) ;Default DTA/Program tail
    57                              <1> endstruc
    58                              <1> 
    59                              <1> struc ffBlock   ;The structure of the Find First structure at the DTA
    60 00000000 ??                  <1>     .driveNum   resb 1  ;Drive we are searching on
    61 00000001 <res Bh>            <1>     .template   resb 11 ;Search template (? meaning anything)
    62 0000000C ??                  <1>     .attrib     resb 1  ;Search attribute
    63 0000000D ????????            <1>     .dirOffset  resd 1  ;32 byte entry within dir cluster
    64 00000011 ????????            <1>     .parDirClus resd 1  ;Parent Directory Cluster number
    65 00000015 ??                  <1>     .attribFnd  resb 1  ;Attrib of file found
    66 00000016 ????                <1>     .fileTime   resw 1  ;File time
    67 00000018 ????                <1>     .fileDate   resw 1  ;File date
    68 0000001A ????????            <1>     .fileSize   resd 1  ;Number of bytes
    69 0000001E <res Dh>            <1>     .asciizName resb 13 ;ASCIIZ name with dot and terminating nul
    70                              <1> endstruc
    29                                  Segment .text align=1 
    30                                  %include "./Source/edmain.asm"
     1                              <1> ;Contains the program loader
     2                              <1> start:
     3 00000000 EB01                <1>     jmp short .cVersion
     4 00000002 01                  <1> .vNum:          db 1    ;Main version number, patchable
     5                              <1> .cVersion:
     6 00000003 FC                  <1>     cld
     7 00000004 B800300000          <1>     mov eax, 3000h  ;Get version number
     8 00000009 CD41                <1>     int 41h
     9 0000000B 3A05F1FFFFFF        <1>     cmp al, byte [.vNum]
    10 00000011 760C                <1>     jbe short okVersion
    11 00000013 488D15(39000000)    <1>     lea rdx, badVerStr
    12 0000001A E93D020000          <1>     jmp badExitMsg
    13                              <1> okVersion:
    14                              <1> ;Initialise the BSS and to 0
    15 0000001F 488D3D(00000000)    <1>     lea rdi, section..bss.start
    16 00000026 48B94B030000000000- <1>     mov rcx, bssLen
    16 0000002F 00                  <1>
    17 00000030 31C0                <1>     xor eax, eax
    18 00000032 F3AA                <1>     rep stosb
    19                              <1> ;One command line argument except for mandatory filename, /B=(binary read)
    20 00000034 B800370000          <1>     mov eax, 3700h
    21 00000039 CD41                <1>     int 41h
    22 0000003B B85C000000          <1>     mov eax, "\"    ;Default pathsep
    23 00000040 B92F000000          <1>     mov ecx, "/"    ;Alternative pathsep
    24 00000045 80FA2D              <1>     cmp dl, "-"     ;Is the switch char default or alternative?
    25 00000048 0F44C1              <1>     cmove eax, ecx  ;Move if alternative
    26 0000004B 88D3                <1>     mov bl, dl  ;Preserve switch char in bl
    27 0000004D 881D(01000000)      <1>     mov byte [switchChar], bl
    28 00000053 8805(00000000)      <1>     mov byte [pathsepChar], al
    29                              <1> getCmdTail:
    30 00000059 B801610000          <1>     mov eax, 6101h  ;Get parsed FCB and cmdtail for filename in rdx
    31 0000005E CD41                <1>     int 41h
    32                              <1> ;Now parse the command line, to get full command spec for filename.
    33 00000060 488D7A25            <1>     lea rdi, qword [rdx + cmdArgs.progTail]     ;Get ptr to tail
    34 00000064 0FB64A24            <1>     movzx ecx, byte [rdx + cmdArgs.parmList]    ;Get number of chars in cmdline
    35                              <1> cmdTailParse:
    36 00000068 B020                <1>     mov al, SPC ;Comparing against a space
    37                              <1> .searchLoop:
    38 0000006A F3AE                <1>     repe scasb  ;Search for the first non-space char
    39 0000006C 67E366              <1>     jecxz .parseComplete    ;If we run out of chars, exit!
    40 0000006F 385FFF              <1>     cmp byte [rdi - 1], bl  ;Did we find a switchchar?
    41 00000072 7539                <1>     jne short .notSwitch
    42 00000074 8A07                <1>     mov al, byte [rdi]      ;Get the char after the switch
    43                              <1>     ;Now we lookahead only if we have more than 1 char left in buffer
    44 00000076 81F901000000        <1>     cmp ecx, 1  ;If we have 1 char left, automatically accept as arg
    45 0000007C 7419                <1>     je short .goodSwitch
    46 0000007E 8A6701              <1>     mov ah, byte byte [rdi + 1] ;Lookahead
    47 00000081 80FC20              <1>     cmp ah, SPC ;If char after switchchar is SPC, accept
    48 00000084 7411                <1>     je short .goodSwitch
    49                              <1> .parseBadExit:
    50 00000086 E9CA010000          <1>     jmp badParmExit
    51                              <1> .nameBadExit:
    52 0000008B 488D15(6B000000)    <1>     lea rdx, badNameStr
    53 00000092 E9C5010000          <1>     jmp badExitMsg
    54                              <1> .goodSwitch:
    55 00000097 24DF                <1>     and al, ~20h    ;Clear the lowercase flag
    56 00000099 3C42                <1>     cmp al, "B"     ;The flag is /B
    57 0000009B 75E9                <1>     jne short .parseBadExit
    58 0000009D C605(04000000)FF    <1>     mov byte [noEofCheck], -1   ;Set the internal flag
    59 000000A4 48FFC7              <1>     inc rdi ;Move rdi to the char after the B
    60 000000A7 FFC9                <1>     dec ecx ;And decrement count of chars left
    61 000000A9 742A                <1>     jz short .parseComplete
    62 000000AB EBBD                <1>     jmp short .searchLoop   ;Now skip next lot of spaces
    63                              <1> .notSwitch:
    64                              <1>     ;Thus rdi must point one char past the start of a filename. 
    65                              <1>     ;If there is no filename, accept the pointer. 
    66                              <1>     ;If not, fail.
    67 000000AD 48813D(14000000)00- <1>     cmp qword [tmpNamePtr], 0
    67 000000B5 000000              <1>
    68 000000B8 75CC                <1>     jnz short .parseBadExit ;If its not empty, too many filenames passed in
    69 000000BA 48FFCF              <1>     dec rdi
    70 000000BD 48893D(14000000)    <1>     mov qword [tmpNamePtr], rdi ;Store the ptr temporarily here
    71 000000C4 48FFC7              <1>     inc rdi
    72 000000C7 F2AE                <1>     repne scasb ;Now we keep going until we hit a space
    73 000000C9 48893D(1C000000)    <1>     mov qword [tmpNamePtr2], rdi    ;Store first char past end of name here.
    74 000000D0 3847FF              <1>     cmp byte [rdi - 1], al  ;Was this a space or run out of chars?
    75 000000D3 7495                <1>     je short .searchLoop    ;Jump if a space, else, we parsed the tail.
    76                              <1> .parseComplete:
    77                              <1> ;Check we have a pointer to a filename AT LEAST.
    78 000000D5 48813D(14000000)00- <1>     cmp qword [tmpNamePtr], 0
    78 000000DD 000000              <1>
    79 000000E0 74A9                <1>     je short .nameBadExit
    80                              <1> ;Now we copy the filename internally.
    81 000000E2 488D3D(3C000000)    <1>     lea rdi, pathspec
    82 000000E9 488B35(14000000)    <1>     mov rsi, qword [tmpNamePtr]
    83                              <1> nameCopy:
    84 000000F0 A4                  <1>     movsb   ;Copy one char at a time
    85 000000F1 483B35(1C000000)    <1>     cmp rsi, qword [tmpNamePtr2]    ;Check if we are equal to end of string ptr
    86 000000F8 75F6                <1>     jne short nameCopy
    87 000000FA 31C0                <1>     xor eax, eax
    88 000000FC AA                  <1>     stosb   ;Store the null terminating char
    89 000000FD 488D3D(3C000000)    <1>     lea rdi, pathspec
    90 00000104 4889FE              <1>     mov rsi, rdi
    91 00000107 B800600000          <1>     mov eax, 6000h  ;TRUENAME the filename
    92 0000010C CD41                <1>     int 41h
    93 0000010E 731D                <1>     jnc short .nameGood ;Name ok, proceed
    94 00000110 3C0F                <1>     cmp al, errBadDrv
    95 00000112 750C                <1>     jne short .genericError
    96 00000114 488D15(4F000000)    <1>     lea rdx, badDrvStr
    97 0000011B E93C010000          <1>     jmp badExitMsg
    98                              <1> .genericError:
    99 00000120 488D15(C5000000)    <1>     lea rdx, badFileStr ;If this fails, bad filespec
   100 00000127 0F822F010000        <1>     jc badExitMsg  ;The filename is bad for some reason!
   101                              <1> .nameGood:
   102                              <1>     ;Now invalidate tmpNamePtr and tmpNamePtr2
   103 0000012D 31C9                <1>     xor ecx, ecx
   104 0000012F 48890D(14000000)    <1>     mov qword [tmpNamePtr], rcx
   105 00000136 48890D(1C000000)    <1>     mov qword [tmpNamePtr2], rcx
   106 0000013D 48FFC9              <1>     dec rcx
   107 00000140 488D3D(3C000000)    <1>     lea rdi, pathspec
   108 00000147 31C0                <1>     xor eax, eax
   109 00000149 F3AE                <1>     rep scasb   ;rdi points past terminating null
   110                              <1>     ;Find the nearest pathsep (since we have fully qualified the name)
   111 0000014B FD                  <1>     std
   112 0000014C 0FB605(00000000)    <1>     movzx eax, byte [pathsepChar]   ;Get pathsep char in al
   113 00000153 F3AE                <1>     rep scasb
   114 00000155 FC                  <1>     cld
   115 00000156 4881C702000000      <1>     add rdi, 2  ;Point rdi to first char past the pathsep
   116 0000015D 48893D(14000000)    <1>     mov qword [fileNamePtr], rdi    ;Save the ptr
   117                              <1>     ;Now convert into an FCB name and back to ASCIIZ string 
   118                              <1>     ; at the end of the provided pathspec
   119 00000164 4889F7              <1>     mov rdi, rsi
   120 00000167 488D3D(28000000)    <1>     lea rdi, fcbBuffer
   121 0000016E 56                  <1>     push rsi
   122 0000016F 57                  <1>     push rdi
   123 00000170 E876010000          <1>     call asciiToFCB
   124 00000175 5E                  <1>     pop rsi ;Swap the pointers
   125 00000176 5F                  <1>     pop rdi
   126 00000177 E8AB010000          <1>     call FCBToAsciiz
   127 0000017C B02E                <1>     mov al, "."
   128 0000017E 488B3D(14000000)    <1>     mov rdi, qword [fileNamePtr]    ;Get the ptr to the 8.3 filename
   129 00000185 B908000000          <1>     mov ecx, 8
   130 0000018A F2AE                <1>     repne scasb   ;Now scan for the extension separator
   131                              <1>     ;rdi points just after the separator.
   132 0000018C 48893D(1C000000)    <1>     mov qword [fileExtPtr], rdi
   133                              <1> ;Now we have all the metadata for the filename we are working with
   134 00000193 488D15(3F010000)    <1>     lea rdx, badFileExt
   135 0000019A 8B07                <1>     mov eax, dword [rdi]
   136 0000019C 3D42414B00          <1>     cmp eax, "BAK"  ;Is this a bakup file?
   137 000001A1 0F84B5000000        <1>     je badExitMsg   ;If yes, error!
   138                              <1> ;Now we check to make sure the path has no global filename chars
   139                              <1> wildcardCheck:
   140 000001A7 488D35(3C000000)    <1>     lea rsi, pathspec
   141                              <1> .mainlp:
   142 000001AE AC                  <1>     lodsb
   143 000001AF 84C0                <1>     test al, al ;Once we're at the null char, proceed
   144 000001B1 7414                <1>     jz short fileOpen
   145 000001B3 3C3F                <1>     cmp al, "?"
   146 000001B5 7404                <1>     je short .error
   147 000001B7 3C2A                <1>     cmp al, "*"
   148 000001B9 75F3                <1>     jne short .mainlp
   149                              <1> .error:
   150 000001BB 488D15(4F000000)    <1>     lea rdx, badDrvStr
   151 000001C2 E995000000          <1>     jmp badExitMsg
   152                              <1> ;Now we open the file to check if it exists and if it does, if it is readonly
   153                              <1> fileOpen:
   154                              <1> ;first set the handles to -1
   155 000001C7 C705(24000000)FFFF- <1>     mov dword [readHdl], -1 ;Init the handles to -1
   155 000001CF FFFF                <1>
   156 000001D1 488D15(3C000000)    <1>     lea rdx, pathspec
   157 000001D8 B906000000          <1>     mov ecx, dirIncFiles
   158 000001DD B8004E0000          <1>     mov eax, 4E00h  ;Find First 
   159 000001E2 CD41                <1>     int 41h
   160 000001E4 7254                <1>     jc short .fileNotFound
   161                              <1> ;Check if file is read only
   162 000001E6 B8002F0000          <1>     mov eax, 2F00h  ;Get a pointer to the DTA in rbx
   163 000001EB CD41                <1>     int 41h
   164 000001ED F6431501            <1>     test byte [rbx + ffBlock.attribFnd], dirReadOnly
   165 000001F1 7407                <1>     jz short .notReadOnly
   166                              <1> ;Read only files here
   167 000001F3 C605(02000000)FF    <1>     mov byte [roFlag], -1   ;Set read only flag!
   168                              <1> .notReadOnly:
   169                              <1> ;File exists, lets rename it to have a .BAK extension
   170 000001FA 488D35(3C000000)    <1>     lea rsi, pathspec
   171 00000201 488D3D(BC000000)    <1>     lea rdi, bkupfile
   172 00000208 E888000000          <1>     call strcpyASCIIZ
   173 0000020D 56                  <1>     push rsi
   174 0000020E 57                  <1>     push rdi
   175 0000020F 488B3D(1C000000)    <1>     mov rdi, qword [fileExtPtr] ;Get the pointer to the extension
   176 00000216 4881C780000000      <1>     add rdi, pspecLen   ;Now make it an offset into the new buffer
   177 0000021D C70742414B00        <1>     mov dword [rdi], "BAK"  ;Change it into a BAK,0 file
   178 00000223 5F                  <1>     pop rdi
   179 00000224 5E                  <1>     pop rsi
   180 00000225 B800560000          <1>     mov eax, 5600h
   181 0000022A CD41                <1>     int 41h
   182 0000022C 730C                <1>     jnc short .backupMade
   183 0000022E 488D15(64010000)    <1>     lea rdx, badBkupStr
   184 00000235 E922000000          <1>     jmp badExitMsg
   185                              <1> .backupMade:
   186                              <1> ;File renamed to backup!
   187                              <1> 
   188                              <1> .fileNotFound:
   189                              <1> ;Maybe new file? Check reason for error! If FNF, its good!
   190 0000023A 663D0200            <1>     cmp ax, errFnf  ;If its a file not found error, then we are good!
   191 0000023E 488D15(A8000000)    <1>     lea rdx, badOpenStr ;We can't open the file for whatever
   192 00000245 7515                <1>     jne badExitMsg
   193                              <1> ;Error was file not found so we can make the file!
   194 00000247 C605(03000000)FF    <1>     mov byte [newFileFlag], -1  ;Set the new file flag!
   195                              <1>     
   196                              <1> exitOk:
   197                              <1> ;Let DOS take care of freeing all resources
   198 0000024E B8004C0000          <1>     mov eax, 4C00h
   199 00000253 CD41                <1>     int 41h
   200                              <1> 
   201                              <1> ;----Bad Exits----
   202                              <1> badParmExit:
   203 00000255 488D15(E7000000)    <1>     lea rdx, badParm    ;Bad number of parameters
   204                              <1> badExitMsg:
   205 0000025C 4885D2              <1>     test rdx, rdx   ;Check if null ptr => Dont print on exit
   206 0000025F 7407                <1>     jz short .noPrint
   207 00000261 B800090000          <1>     mov eax, 0900h
   208 00000266 CD41                <1>     int 41h
   209                              <1> .noPrint:
   210 00000268 B8FF4C0000          <1>     mov eax, 4CFFh
   211 0000026D CD41                <1>     int 41h
    31                                  %include "./Source/edutils.asm"
     1                              <1> ;Utility functions for edlin go here
     2                              <1> 
     3                              <1> strlen:
     4                              <1> ;String length based on terminator in al
     5                              <1> ;Input: rsi -> Source Ptr
     6                              <1> ;       al = Terminating char to search for
     7                              <1> ;Output: ecx = Number of chars instring including terminator
     8 0000026F 31C9                <1>     xor ecx, ecx
     9 00000271 FFC9                <1>     dec ecx
    10 00000273 57                  <1>     push rdi
    11 00000274 4889F7              <1>     mov rdi, rsi
    12 00000277 F2AE                <1>     repne scasb
    13 00000279 5F                  <1>     pop rdi
    14 0000027A F7D9                <1>     neg ecx ;Take 2's compliment to get number of chars including terminator
    15                              <1>     return
    13                              <2> %%_ret:
    14 0000027C C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    16                              <1> 
    17                              <1> strcpy:
    18                              <1> ;Copies a string from one buffer to another
    19                              <1> ;Input: rsi -> Source Ptr
    20                              <1> ;       rdi -> Destination Ptr
    21 0000027D 56                  <1>     push rsi
    22 0000027E 57                  <1>     push rdi
    23 0000027F 51                  <1>     push rcx
    24 00000280 B9FD000000          <1>     mov ecx, lineLen    ;Max number of chars in a string
    25                              <1> .lp:
    26 00000285 E83B000000          <1>     call isCharEOL
    27 0000028A 7405                <1>     je short .exit
    28 0000028C A4                  <1>     movsb   ;Move the char over, inc both pointers
    29 0000028D FFC9                <1>     dec ecx
    30 0000028F 75F4                <1>     jnz short .lp
    31                              <1> .exit:
    32 00000291 59                  <1>     pop rcx
    33 00000292 5F                  <1>     pop rdi
    34 00000293 5E                  <1>     pop rsi
    35                              <1>     return
    13                              <2> %%_ret:
    14 00000294 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    36                              <1> 
    37                              <1> strcpyASCIIZ:
    38                              <1> ;Copies a ASCIIZ string from one buffer to another. 
    39                              <1> ;Pointers don't move.
    40                              <1> ;Input: rsi -> Source Ptr
    41                              <1> ;       rdi -> Destination Ptr
    42 00000295 56                  <1>     push rsi
    43 00000296 57                  <1>     push rdi
    44                              <1> .cpChar:
    45 00000297 AC                  <1>     lodsb
    46 00000298 AA                  <1>     stosb
    47 00000299 84C0                <1>     test al, al ;Was this a nul char?
    48 0000029B 75FA                <1>     jnz .cpChar
    49 0000029D 5F                  <1>     pop rdi
    50 0000029E 5E                  <1>     pop rsi
    51                              <1>     return
    13                              <2> %%_ret:
    14 0000029F C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    52                              <1> 
    53                              <1> 
    54                              <1> memmove:
    55                              <1> ;Copies a number of bytes over from one buffer to another
    56                              <1> ;Input: rsi -> Source Ptr
    57                              <1> ;       rdi -> Destination Ptr
    58                              <1> ;       ecx = Count of chars to copy
    59 000002A0 56                  <1>     push rsi
    60 000002A1 57                  <1>     push rdi
    61 000002A2 51                  <1>     push rcx
    62 000002A3 F3A4                <1>     rep movsb
    63 000002A5 59                  <1>     pop rcx
    64 000002A6 5F                  <1>     pop rdi
    65 000002A7 5E                  <1>     pop rsi
    66                              <1>     return
    13                              <2> %%_ret:
    14 000002A8 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    67                              <1> 
    68                              <1> memset:
    69                              <1> ;Initialises a buffer to contain a particular value
    70                              <1> ;Input: rdi -> Buffer to set to given value
    71                              <1> ;       al = Value to set the buffer to
    72                              <1> ;       rcx = Number of bytes in buffer
    73 000002A9 51                  <1>     push rcx
    74 000002AA 57                  <1>     push rdi
    75 000002AB F3AA                <1>     rep stosb
    76 000002AD 5F                  <1>     pop rdi
    77 000002AE 59                  <1>     pop rcx
    78                              <1>     return
    13                              <2> %%_ret:
    14 000002AF C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    79                              <1> 
    80                              <1> findLineEnd:
    81                              <1> ;Returns in rsi a pointer to the end of the line
    82                              <1> ;Input: rsi -> Start of the line find the end of
    83                              <1> ;Output: rsi -> Last char in the string (NOTE: LAST CHAR NOT PAST)
    84                              <1> ;Trashes: rcx
    85 000002B0 B9FD000000          <1>     mov ecx, lineLen
    86                              <1> .lp:
    87 000002B5 E80B000000          <1>     call isCharEOL  ;If ZF=ZE, then rsi points to EOL
    88                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000002BA 74(AF)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    89 000002BC FFC9                <1>     dec ecx
    90                              <1>     retz    ;If ecx is now 0, means rsi points to the end of line (NO EOL CHAR)
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000002BE 74(AF)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    91 000002C0 48FFC6              <1>     inc rsi
    92 000002C3 EBF0                <1>     jmp short .lp
    93                              <1> 
    94                              <1> isCharEOL:
    95                              <1> ;Input: rsi -> Char/Word to analyse
    96                              <1> ;Output: ZF=ZE if char/word at rsi LF or CR,LF.
    97                              <1> ;        ZF=NZ if not
    98 000002C5 E811000000          <1>     call isCharEOF
    99                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000002CA 74(AF)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   100 000002CC 803E0A              <1>     cmp byte [rsi], LF
   101                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000002CF 74(AF)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   102 000002D1 803E0D              <1>     cmp byte [rsi], CR
   103                              <1>     retne
    53                              <2> cret ne
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000002D4 75(AF)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   104 000002D6 807E010A            <1>     cmp byte [rsi + 1], LF
   105                              <1>     return
    13                              <2> %%_ret:
    14 000002DA C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   106                              <1> 
   107                              <1> isCharEOF:
   108                              <1> ;Input: rsi -> Char to check if it is ^Z
   109                              <1> ;Output: ZF=ZE if char at rsi is ^Z AND we are checking for EOFs
   110                              <1> ;        ZF=NZ if char at rsi is not ^Z or we are not checking for eof's
   111 000002DB 50                  <1>     push rax
   112 000002DC 8A05(04000000)      <1>     mov al, byte [noEofCheck]
   113 000002E2 F6D0                <1>     not al  ;Invert the bits (1's compliment)
   114 000002E4 58                  <1>     pop rax
   115                              <1>     retnz   ;Return if not checking for EOF
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000002E5 75(DA)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   116 000002E7 803E1A              <1>     cmp byte [rsi], EOF ;Check if eof
   117                              <1>     return
    13                              <2> %%_ret:
    14 000002EA C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   118                              <1> 
   119                              <1> 
   120                              <1> asciiToFCB:
   121                              <1> ;Converts a filename in the form FILENAME.EXT,0 to FILENAMEEXT
   122                              <1> ;Will uppercase any lowercase chars as this could be used with user buffers.
   123                              <1> ;Names such as SYS.COM get converted to "SYS     COM"
   124                              <1> ;Name is space padded.
   125                              <1> ;Input: rsi = ASCII string buffer
   126                              <1> ;       rdi = FCB name buffer
   127                              <1> ;Output: al = Char that terminated the source string 
   128 000002EB 53                  <1>     push rbx    
   129 000002EC 57                  <1>     push rdi
   130 000002ED B90B000000          <1>     mov ecx, 11
   131 000002F2 B020                <1>     mov al, " "
   132 000002F4 F3AA                <1>     rep stosb   ;Fill the buffer with spaces (so we don't need to fill later)
   133 000002F6 5F                  <1>     pop rdi
   134 000002F7 4889FB              <1>     mov rbx, rdi    ;Use rbx as the base pointer of this buffer
   135                              <1> .processName:
   136 000002FA AC                  <1>     lodsb   ;Get the char in al
   137 000002FB 84C0                <1>     test al, al
   138 000002FD 7426                <1>     jz .exit
   139 000002FF 3C20                <1>     cmp al, " " ;If space or a period, go to extension field. If null, exit
   140 00000301 7407                <1>     je .extSpace
   141 00000303 3C2E                <1>     cmp al, "."
   142 00000305 740C                <1>     je .ext
   143 00000307 AA                  <1>     stosb   ;Store the char
   144 00000308 EBF0                <1>     jmp short .processName
   145                              <1> .extSpace:
   146                              <1> ;Now we scan for a period in the name
   147 0000030A AC                  <1>     lodsb   ;Get a char and increase rsi
   148 0000030B 84C0                <1>     test al, al
   149 0000030D 7416                <1>     jz .exit
   150 0000030F 3C2E                <1>     cmp al, "."     ;If al is not a period...
   151 00000311 75F7                <1>     jne .extSpace   ; keep searching
   152                              <1> .ext:
   153 00000313 488D7B08            <1>     lea rdi, qword [rbx + filename.fExt]    ;Put destination at the extension
   154                              <1> .processExt:
   155 00000317 AC                  <1>     lodsb
   156 00000318 84C0                <1>     test al, al
   157 0000031A 7409                <1>     jz .exit
   158 0000031C 3C20                <1>     cmp al, " "
   159 0000031E 7405                <1>     je .exit
   160 00000320 AA                  <1>     stosb
   161 00000321 EBF4                <1>     jmp short .processExt
   162                              <1> .exitBadChar:
   163 00000323 30C0                <1>     xor al, al  ;Return a null terminator
   164                              <1> .exit:
   165 00000325 5B                  <1>     pop rbx
   166                              <1>     return
    13                              <2> %%_ret:
    14 00000326 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   167                              <1> 
   168                              <1> FCBToAsciiz:
   169                              <1> ;Converts a filename in the form FILENAMEEXT to FILENAME.EXT,0
   170                              <1> ;Name is space padded too
   171                              <1> ;Input: rsi = FCB name buffer
   172                              <1> ;       rdi = ASCIIZ string buffer
   173 00000327 B908000000          <1>     mov ecx, 8
   174 0000032C F3A4                <1>     rep movsb   ;Move the name over
   175                              <1> .scanNameSpace:
   176 0000032E 807FFF20            <1>     cmp byte [rdi - 1], " " ;Is the previous char a space?
   177 00000332 750D                <1>     jne .ext
   178 00000334 48FFCF              <1>     dec rdi
   179 00000337 FFC1                <1>     inc ecx
   180 00000339 81F908000000        <1>     cmp ecx, 8
   181 0000033F 72ED                <1>     jb .scanNameSpace
   182                              <1> .ext:
   183 00000341 66813E2020          <1>     cmp word [rsi], "  "    ;Are the first two chars a space?
   184 00000346 7506                <1>     jne .validExt
   185 00000348 807E0220            <1>     cmp byte [rsi + 2], " " ;Is the final char a space?
   186 0000034C 7415                <1>     je .exit
   187                              <1> .validExt:
   188 0000034E B02E                <1>     mov al, "." ;We have a valid extension, store a period
   189 00000350 AA                  <1>     stosb
   190 00000351 B903000000          <1>     mov ecx, 3
   191 00000356 F3A4                <1>     rep movsb   ;Move the three extension chars over
   192                              <1> .scanExtSpace:
   193 00000358 807FFF20            <1>     cmp byte [rdi - 1], " " ;Is the previous char a space
   194 0000035C 7505                <1>     jne .exit
   195 0000035E 48FFCF              <1>     dec rdi
   196 00000361 EBF5                <1>     jmp short .scanExtSpace
   197                              <1> .exit:
   198 00000363 31C0                <1>     xor eax, eax
   199 00000365 AA                  <1>     stosb   ;Store a null at the end
   200                              <1>     return
    13                              <2> %%_ret:
    14 00000366 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    32                                  Segment .data align=1 follows=.text 
    33                                  %include "./Data/eddata.asm"
     1                              <1> newFileAllocTable:
     2                              <1> ;Units of paragraphs, less than 1Mb (10000h)
     3 00000000 0080                <1>     dw 8000h    ;512Kb
     4 00000002 0040                <1>     dw 4000h    ;256Kb
     5 00000004 0020                <1>     dw 2000h    ;128Kb
     6 00000006 0010                <1>     dw 1000h    ;64Kb
     7 00000008 0008                <1>     dw 800h     ;32Kb
     8 0000000A 0004                <1>     dw 400h     ;16Kb
     9 0000000C 0002                <1>     dw 200h     ;8Kb
    10 0000000E 0001                <1>     dw 100h     ;4Kb
    11 00000010 8000                <1>     dw 80h      ;2Kb
    12 00000012 4000                <1>     dw 40h      ;1Kb
    13 00000014 2000                <1>     dw 20h      ;512 bytes
    14 00000016 1000                <1>     dw 10h      ;256 bytes
    15 00000018 FFFF                <1>     dw -1       ;End of table marker
    34                                  %include "./Data/edmsg.asm"
     1                              <1> ;Edlin Strings are in this file
     2 0000001A 4E65772066696C65    <1> newStr  db "New file"   ;This string is terminated by the next line
     3 00000022 0D0A24              <1> crlf    db CR,LF,"$"
     4 00000025 456E64206F6620696E- <1> eofStr  db "End of input file",CR,LF,"$"    ;When EOF occurs
     4 0000002E 7075742066696C650D- <1>
     4 00000037 0A24                <1>
     5 00000039 496E76616C69642044- <1> badVerStr   db "Invalid DOS Version",CR,LF,"$"
     5 00000042 4F532056657273696F- <1>
     5 0000004B 6E0D0A24            <1>
     6 0000004F 496E76616C69642044- <1> badDrvStr   db "Invalid Drive or filename",CR,LF,"$"
     6 00000058 72697665206F722066- <1>
     6 00000061 696C656E616D650D0A- <1>
     6 0000006A 24                  <1>
     7 0000006B 46696C65206E616D65- <1> badNameStr  db "File name must be specified",CR,LF,"$"
     7 00000074 206D75737420626520- <1>
     7 0000007D 737065636966696564- <1>
     7 00000086 0D0A24              <1>
     8 00000089 43616E6E6F74206372- <1> badCreatStr db "Cannot create specified file",CR,LF,"$"
     8 00000092 656174652073706563- <1>
     8 0000009B 69666965642066696C- <1>
     8 000000A4 650D0A24            <1>
     9 000000A8 43616E6E6F74206F70- <1> badOpenStr  db "Cannot open specified file",CR,LF,"$"
     9 000000B1 656E20737065636966- <1>
     9 000000BA 6965642066696C650D- <1>
     9 000000C3 0A24                <1>
    10 000000C5 43616E6E6F74207061- <1> badFileStr  db "Cannot parse sepcified filespec",CR,LF,"$"
    10 000000CE 727365207365706369- <1>
    10 000000D7 666965642066696C65- <1>
    10 000000E0 737065630D0A24      <1>
    11 000000E7 496E76616C69642050- <1> badParm     db "Invalid Parameter",CR,LF,"$"
    11 000000F0 6172616D657465720D- <1>
    11 000000F9 0A24                <1>
    12 000000FB 456E74727920657272- <1> badInput    db "Entry error",CR,LF,"$"
    12 00000104 6F720D0A24          <1>
    13 00000109 5265616C6C6F636174- <1> badRealloc  db "Reallocation error",CR,LF,"$"
    13 00000112 696F6E206572726F72- <1>
    13 0000011B 0D0A24              <1>
    14 0000011E 4E6F7420656E6F7567- <1> badMemSize  db "Not enough memory to load file", CR,LF,"$"
    14 00000127 68206D656D6F727920- <1>
    14 00000130 746F206C6F61642066- <1>
    14 00000139 696C650D0A24        <1>
    15 0000013F 43616E6E6F74206564- <1> badFileExt  db "Cannot edit .BAK file--rename file",CR,LF,"$"
    15 00000148 6974202E42414B2066- <1>
    15 00000151 696C652D2D72656E61- <1>
    15 0000015A 6D652066696C650D0A- <1>
    15 00000163 24                  <1>
    16 00000164 43616E6E6F74206D61- <1> badBkupStr  db "Cannot make .BAK file",CR,LF,"$"
    16 0000016D 6B65202E42414B2066- <1>
    16 00000176 696C650D0A24        <1>
    17 0000017C 2A                  <1> prompt      db "*"
    35                                  Segment .bss align=1 follows=.data nobits
    36                                  bssStart:
    37                                  %include "./Data/edbss.asm"
     1 00000000 ??                  <1> pathsepChar db ?    ;Default \, Alternative /
     2 00000001 ??                  <1> switchChar  db ?    ;Default /, Alternative -
     3                              <1> 
     4                              <1> ;All variables that dont need initialisation go here
     5 00000002 ??                  <1> roFlag      db ?    ;Flag is set if file is read-only. Cannot edit the file.
     6 00000003 ??                  <1> newFileFlag db ?    ;Flag indicating the file being made is new (when set, above flag meaningless)
     7 00000004 ??                  <1> noEofCheck  db ?    ;Flag is set if we are not to check for ^Z chars found in the file
     8 00000005 ??                  <1> eofReached  db ?    ;When we reach EOF for file on disk, set to -1, else 0
     9                              <1> 
    10                              <1> ;Memory Related variables
    11 00000006 ????????????????    <1> memPtr      dq ?    ;Ptr to the memory arena given by DOS
    12 0000000E ????????            <1> arenaSize   dd ?    ;Size of the arena in bytes (rounded up to nearest 256 byte boundary)
    13 00000012 ????                <1> numLines    dw ?    ;Number of 256 byte lines in the arena (arena size / 256 bytes)
    14                              <1> 
    15                              <1> tmpNamePtr:         ;Ptr to the filename in the commandtail
    16 00000014 ????????????????    <1> fileNamePtr dq ?    ;Ptr to the name portion of filespec
    17                              <1> tmpNamePtr2:        ;Ptr to the end of the command in the commandtail
    18 0000001C ????????????????    <1> fileExtPtr  dq ?    ;Ptr to the extension of the file we are editing
    19                              <1> ;The above pointers point past the dot or pathseperator
    20                              <1> 
    21                              <1> ;Don't jiggle these symbols, need dword to be together for -1
    22                              <1> readHdl:            ;Symbol for the same file
    23 00000024 ????                <1> fileHdl     dw ?    ;Contain the file handle for the open file
    24                              <1> writeHdl:           ;Symbol for the same file
    25 00000026 ????                <1> tmpHdl      dw ?    ;Handle to the temporary file
    26                              <1> 
    27                              <1> fcbBuffer:
    28 00000028 <res 14h>           <1> tmpName     db 20 dup (?)   ;Space for the ASCIIZ path for tmp name.
    29                              <1> ;                              names of the form ".\12345678.ext",0
    30 0000003C <res 80h>           <1> pathspec    db 128 dup (?)  ;Space for the 128 byte buffer for full filename
    31                              <1> pspecLen    equ $ - pathspec    ;Used to compute the difference between portions.
    32 000000BC <res 80h>           <1> bkupfile    db 128 dup (?)  ;Pathspec for backup file!
    33                              <1> 
    34                              <1> ;Command line variables
    35 0000013C <res 82h>           <1> cmdLine     db halfLine_size dup (?)
    36 000001BE ??                  <1> args        db ?    ;Count of arguments in parsed command line
    37 000001BF ??                  <1> cmdChar     db ?
    38                              <1> ;Arguments are converted to signed words where appropriate
    39                              <1> ; and parsed into here in the order they are encountered in.
    40                              <1> ;
    41 000001C0 ????                <1> arg1        dw ?
    42 000001C2 ????                <1> arg2        dw ?
    43 000001C4 ????                <1> arg3        dw ?
    44 000001C6 ????                <1> arg4        dw ?
    45 000001C8 <res 82h>           <1> argString   db halfLine_size dup (?)    ;Used by search and replace only
    46 0000024A ??                  <1> argPastEnd  db ?    ;0 -> normal, -1 -> Offset from end of mem (indicated by #)
    47                              <1> 
    48                              <1> ;The editLine gets preloaded with the original line before editing
    49                              <1> ;editLine has type "line"
    50 0000024B <res 100h>          <1> editLine    db 256 dup (?)  ;Line in which all editing takes place
    38                                  bssLen equ ($ - bssStart)
    39                                  Segment .stack align=16 follows=.bss nobits
    40                                  ;Use a 200 QWORD stack
    41 00000000 <res 640h>                  dq 200 dup (?)
    42                                  stackTop:
    43                                  endOfProgram:   ;Deallocate from here
    43          ------------------       info: assembly required 1+2+2 passes

