     1                                  [map all ./Listings/edlin.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  ;EDLIN, an absolute last resort file editor.
     5                                  ;
     6                                  ;                       !!DONT FORGET!!
     7                                  ;       Each line is terminated first with 0Dh then 0Ah (CR,LF)
     8                                  ;                       !!DONT FORGET!!
     9                                  ;
    10                                  
    11                                  ;Edlin will always produce a backup file and refuses to open files 
    12                                  ; with .BAK extension (backup files)
    13                                  
    14                                  ;Edlin will erase the previous backup if one exists, ensuring there
    15                                  ; is enough free space for a new copy of the backup.
    16                                  ;It then creates a new file with the filename with a $$$ extension.
    17                                  ;All edits occur in memory and are flushed to it. We then rename it
    18                                  ; to the desired filename.
    19                                  ;BAK files cannot be opened.
    20                                  ;
    21                                  ;Empty lines are default just a CR,LF pair
    22                                  
    23                                  ;Edlin has two modes of operation: Command and Edit
    24                                  
    25                                  %include "./Include/dosMacro.mac"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------------------------------
     3                              <1> ;Generic Macros file
     4                              <1> ;The following instruction extensions allow to conditionally return
     5                              <1> ;The idea was borrowed from the DOS Source Code
     6                              <1> ;
     7                              <1> ;-------------------------------------------------------------------------------
     8                              <1> 
     9                              <1> ;-------------------------------------------------------------------------------
    10                              <1> ;These macros are live and must not be touched
    11                              <1> ;-------------------------------------------------------------------------------
    12                              <1> %macro return 0
    13                              <1> %%_ret:
    14                              <1>     ret
    15                              <1> %assign retOff %%_ret-$$  ;Get offset into segment of %%_ret
    16                              <1> %endmacro
    17                              <1> 
    18                              <1> %macro cret 1
    19                              <1> %%_base:
    20                              <1> %assign baseVar %%_base-$$ ;Get offset into segment of %%_base
    21                              <1>     %ifdef retOff
    22                              <1>     %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <1>     %ifdef currSegVBase
    24                              <1>     j%+1 short (retOff+currSegVBase)
    25                              <1>     %else
    26                              <1>     j%+1 short retOff
    27                              <1>     %endif  ;End ifdef currSegVBase
    28                              <1>     %else 
    29                              <1>     j%-1 short %%a
    30                              <1>     return
    31                              <1> %%a:
    32                              <1>     %endif  ;End the distance measurement if
    33                              <1>     %else   
    34                              <1>     j%-1 short %%a
    35                              <1>     return
    36                              <1> %%a:
    37                              <1>     %endif  ;End ifdef retoff
    38                              <1> %endmacro
    39                              <1> 
    40                              <1> %macro retz 0
    41                              <1> cret z
    42                              <1> %endmacro
    43                              <1> 
    44                              <1> %macro retnz 0
    45                              <1> cret nz
    46                              <1> %endmacro
    47                              <1> 
    48                              <1> %macro rete 0
    49                              <1> cret e
    50                              <1> %endmacro
    51                              <1> 
    52                              <1> %macro retne 0
    53                              <1> cret ne
    54                              <1> %endmacro
    55                              <1> 
    56                              <1> %macro retc 0
    57                              <1> cret c
    58                              <1> %endmacro
    59                              <1> 
    60                              <1> %macro retnc 0
    61                              <1> cret nc
    62                              <1> %endmacro
    63                              <1> 
    64                              <1> %macro retb 0
    65                              <1> cret b
    66                              <1> %endmacro
    67                              <1> 
    68                              <1> %macro retnb 0
    69                              <1> cret nb
    70                              <1> %endmacro
    71                              <1> 
    72                              <1> %macro reta 0
    73                              <1> cret a
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> %macro retna 0
    77                              <1> cret na
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro breakpoint 0
    81                              <1> xchg bx, bx
    82                              <1> %endmacro
    26                                  %include "./Include/dosError.inc"
     1                              <1> ;DOS Error codes
     2                              <1> 
     3                              <1> ;Extended Error Codes
     4                              <1> errInvFnc   equ 1   ;Invalid function number
     5                              <1> errFnf      equ 2   ;File not found
     6                              <1> errPnf      equ 3   ;Path not found
     7                              <1> errNhl      equ 4   ;Too many open handles, no handles left
     8                              <1> errAccDen   equ 5   ;Access denied (to resource)
     9                              <1> errBadHdl   equ 6   ;Invalid handle
    10                              <1> errMCBbad   equ 7   ;MCB's destroyed
    11                              <1> errNoMem    equ 8   ;Insufficient memory
    12                              <1> errMemAddr  equ 9   ;Invalid Memory Block Address
    13                              <1> errBadEnv   equ 10  ;Invalid environment
    14                              <1> errBadFmt   equ 11  ;Invalid format (path etc)
    15                              <1> errAccCde   equ 12  ;Invalid Access Code    ?
    16                              <1> errInvDat   equ 13  ;Invalid data
    17                              <1> ;           equ 14  ;Reserved
    18                              <1> errBadDrv   equ 15  ;Invalid drive specified
    19                              <1> errDelCD    equ 16  ;Attempt to delete the current directory
    20                              <1> errDevUnk   equ 17  ;Not the same device (Device Unknown)
    21                              <1> errNoFil    equ 18  ;No more files, no match found
    22                              <1> ;The following are Driver error codes + 19
    23                              <1> drvErrShft  equ 19  ;Used to shift Driver error codes to extended error codes
    24                              <1> errWpd      equ 19  ;Attempt to write on write protected disk
    25                              <1> errUnkUnt   equ 20  ;Unknown Unit
    26                              <1> errDrvNR    equ 21  ;Drive not ready
    27                              <1> errUnkCmd   equ 22  ;Unknown Command
    28                              <1> errCRCerr   equ 23  ;Data (CRC) error
    29                              <1> errBadRLn   equ 24  ;Bad request structure length
    30                              <1> errSekErr   equ 25  ;Seek error
    31                              <1> errUnkMed   equ 26  ;Unknown media type
    32                              <1> errSecNF    equ 27  ;Sector not Found
    33                              <1> errNoPap    equ 28  ;Printer out of paper
    34                              <1> errWF       equ 29  ;Write fault
    35                              <1> errRF       equ 30  ;Read fault
    36                              <1> errGF       equ 31  ;General fault
    37                              <1> ;----------------------------------------------
    38                              <1> ;The following two go inbetween the Disk errors
    39                              <1> errShrVio   equ 32  ;Sharing violations
    40                              <1> errLokVio   equ 33  ;File Lock violation
    41                              <1> ;----------------------------------------------
    42                              <1> errIDC      equ 34  ;Driver code, Invalid Disk Change
    43                              <1> errNoFCB    equ 35  ;FCB unavailable
    44                              <1> errShrFul   equ 36  ;Sharing buffer full
    45                              <1> 
    46                              <1> errNoNet    equ 50  ;Network request not supported, generic net fail
    47                              <1> 
    48                              <1> errFilExist equ 80  ;File already exists
    49                              <1> errDirExist equ 82  ;Directory already exists
    50                              <1> errFI44     equ 83  ;Fail on INT 44h
    51                              <1> errRedir    equ 84  ;Too many levels of redirection
    52                              <1> errDupRedir equ 85  ;Trying to redirect a redirection
    53                              <1> errBadPass  equ 86  ;Bad password
    54                              <1> errBadParam equ 87  ;Bad parameter passed to request
    55                              <1> errNetWrite equ 88  ;Network Write Fault
    56                              <1> ;-----------------------------------------------------------------------------
    57                              <1> ;Error Loci
    58                              <1> eLocUnk     equ 1   ;Unknown locus, nonspecific or not appropriate
    59                              <1> eLocDsk     equ 2   ;Disk, related to Random Access to a disk or block device
    60                              <1> eLocNet     equ 3   ;Network related issues, shouldnt affect us (yet!)
    61                              <1> eLocChr     equ 4   ;Serial/Character Device error
    62                              <1> eLocMem     equ 5   ;Related to RAM
    63                              <1> ;-----------------------------------------------------------------------------
    64                              <1> ;Error Actions
    65                              <1> eActRet     equ 1   ;Retry
    66                              <1> eActDRet    equ 2   ;Delay then retry (Try again later)
    67                              <1> eActUsr     equ 3   ;Ask user to re-input data, i.e. bad filename or something
    68                              <1> eActAbt     equ 4   ;Abort with cleanup
    69                              <1> eActKil     equ 5   ;Abort without cleanup
    70                              <1> eActIgn     equ 6   ;Ignore error
    71                              <1> eActRetUsr  equ 7   ;Retry after user intervention (i.e swap remdev)
    72                              <1> ;-----------------------------------------------------------------------------
    73                              <1> ;Error classes
    74                              <1> eClsOoR     equ 1   ;Out of resources, no mem or handles
    75                              <1> eClsTS      equ 2   ;Temp sitch, should go away
    76                              <1> eClsAuth    equ 3   ;Authorisation, e.g. file permission error 
    77                              <1> eClsInt     equ 4   ;Internal DOS error or bug
    78                              <1> eClsHrdFlt  equ 5   ;Hardware Failure
    79                              <1> eClsSysFlt  equ 6   ;System Failure, i.e. missing or bad cfg files
    80                              <1> eClsAppFlt  equ 7   ;Application Program error, inconsistent requests etc...
    81                              <1> eClsNotFnd  equ 8   ;Resource not found (such as free SFT entry etc...)
    82                              <1> eClsBadFmt  equ 9   ;Bad format for resource
    83                              <1> eClsLocked  equ 10  ;Resource Locked
    84                              <1> eClsMedia   equ 11  ;Error is on medium, i.e. wrong or damaged remdev
    85                              <1> eClsClash   equ 12  ;Resource already exists!
    86                              <1> eClsUnk     equ 13  ;Unknown class
    27                                  %include "./Include/edStruc.inc"
     1                              <1> ;edlin structures
     2                              <1> lineLen     equ 253
     3                              <1> halflineLen equ 128
     4                              <1> maxLine     equ 65529
     5                              <1> maxAlloc    equ maxLine*lineLen
     6                              <1> maxParas    equ (maxAlloc >> 4) + 1
     7                              <1> fileRO      equ 1   ;Mask for Read Only
     8                              <1> fileDir     equ 10h ;Mask for Directory
     9                              <1> 
    10                              <1> ;Bona-Fida Structures
    11                              <1> 
    12                              <1> struc line
    13 00000000 ??                  <1>     .bBufLen    db ?    ;Buffer size (255)
    14 00000001 ??                  <1>     .bStrLen    db ?    ;Length of the string entered in buffer
    15 00000002 <res FDh>           <1>     .pString    db lineLen dup (?)      ;Actual string itself
    16                              <1> endstruc
    17                              <1> 
    18                              <1> struc halfLine
    19 00000000 ??                  <1>     .bBufLen    db ?    ;Buffer size (130)
    20 00000001 ??                  <1>     .bStrLen    db ?    ;Length of the string entered in buffer
    21 00000002 <res 80h>           <1>     .pString    db halflineLen dup (?)   ;Actual string itself
    22                              <1> endstruc
    28                                  %include "./Include/dosStruc.inc"
     1                              <1> ;Structures and equates coming from DOS
     2                              <1> 
     3                              <1> ;MISC ASCII control chars
     4                              <1> NUL equ 00h ;^@         | ASCII Null
     5                              <1> ETX equ 03h ;^C         | ASCII Break (End of Text)
     6                              <1> ACK equ 06h ;^F         | ASCII Acknowledgement
     7                              <1> BEL equ 07h ;^G         | ASCII Bell
     8                              <1> BSP equ 08h ;^H         | ASCII Backspace
     9                              <1> TAB equ 09h ;^I         | ASCII Horizontal Tab
    10                              <1> LF  equ 0Ah ;^J         | ASCII Line Feed
    11                              <1> CR  equ 0Dh ;^M         | ASCII Carriage Return
    12                              <1> DLE equ 10h ;^P         | ASCII Data Link End (Toggle Print Echo)
    13                              <1> DC3 equ 13h ;^S         | ASCII Device Control 3 (Toggle Scroll Lock)
    14                              <1> DC4 equ 14h ;^T         | ASCII Device Control 4
    15                              <1> NAK equ 15h ;^U         | ASCII Negative Acknowledgement
    16                              <1> ETB equ 17h ;^W         | ASCII End of Transmission Block
    17                              <1> EOF equ 1Ah ;^Z         | ASCII Substitute character (End of File)
    18                              <1> ESC equ 1Bh ;           | ASCII Escape char, used for ANSI.SYS
    19                              <1> SPC equ 20h ;Printable  | ASCII Space
    20                              <1> ;This last one is NEVER printed with a caret as it is a console control char
    21                              <1> DEL equ 7Fh ;^?         | ASCII Rubout (Del char and dec cursor)
    22                              <1> 
    23                              <1> asciiCaret  equ 20h ;Used to check which chars need to be printed with caret
    24                              <1> ;Extended Ascii Codes
    25                              <1> eF1     equ 3Bh ;F1 second byte
    26                              <1> eF2     equ 3Ch ;F2 second byte
    27                              <1> eF3     equ 3Dh ;F3 second byte
    28                              <1> eF4     equ 3Eh ;F4 second byte
    29                              <1> eF5     equ 3Fh ;F5 second byte
    30                              <1> eF6     equ 40h ;F6 second byte
    31                              <1> eF7     equ 41h ;F7 second byte
    32                              <1> eCursL  equ 4Bh ;Cursor Left second byte
    33                              <1> eCursR  equ 4Dh ;Cursor Right second byte
    34                              <1> eIns    equ 52h ;Insert second byte
    35                              <1> eDel    equ 53h ;DEL second byte (not necessarily delete key)
    36                              <1> 
    37                              <1> 
    38                              <1> struc cmdArgs   ;Ptr returned in rdx after 41h/6101h has this structure
    39 00000000 <res 10h>           <1>     .fcb1       db 16 dup (?)  ;First FCB,    argument 1
    40 00000010 <res 14h>           <1>     .fcb2       db 20 dup (?)  ;Second FCB,   argument 2
    41                              <1>     .dta:   ;Pointer to the default DTA in the
    42 00000024 ??                  <1>     .parmList   db ?   ;Number of characters in command tail
    43 00000025 <res 7Fh>           <1>     .progTail   db 127 dup (?) ;Default DTA/Program tail
    44                              <1> endstruc
    45                              <1> 
    46                              <1> struc ffBlock   ;The structure of the Find First structure at the DTA
    47 00000000 ??                  <1>     .driveNum   resb 1  ;Drive we are searching on
    48 00000001 <res Bh>            <1>     .template   resb 11 ;Search template (? meaning anything)
    49 0000000C ??                  <1>     .attrib     resb 1  ;Search attribute
    50 0000000D ????????            <1>     .dirOffset  resd 1  ;32 byte entry within dir cluster
    51 00000011 ????????            <1>     .parDirClus resd 1  ;Parent Directory Cluster number
    52 00000015 ??                  <1>     .attribFnd  resb 1  ;Attrib of file found
    53 00000016 ????                <1>     .fileTime   resw 1  ;File time
    54 00000018 ????                <1>     .fileDate   resw 1  ;File date
    55 0000001A ????????            <1>     .fileSize   resd 1  ;Number of bytes
    56 0000001E <res Dh>            <1>     .asciizName resb 13 ;ASCIIZ name with dot and terminating nul
    57                              <1> endstruc
    29                                  Segment .text align=1 
    30                                  %include "./Source/edmain.asm"
     1                              <1> ;Main EDLIN file
     2                              <1> start:
     3 00000000 EB01                <1>     jmp short .cVersion
     4 00000002 01                  <1> .vNum:          db 1    ;Main version number, patchable
     5                              <1> .cVersion:
     6 00000003 0FB6D8              <1>     movzx ebx, al   ;Save drive number validity in bl
     7 00000006 FC                  <1>     cld
     8 00000007 B800300000          <1>     mov eax, 3000h  ;Get version number
     9 0000000C CD41                <1>     int 41h
    10 0000000E 3A05EEFFFFFF        <1>     cmp al, byte [.vNum]
    11 00000014 761A                <1>     jbe short okVersion
    12 00000016 488D15(1F000000)    <1>     lea rdx, badVerStr
    13                              <1> badExitMsg:
    14 0000001D 4885D2              <1>     test rdx, rdx   ;Check if null ptr => Dont print on exit
    15 00000020 7407                <1>     jz short .noPrint
    16 00000022 B800090000          <1>     mov eax, 0900h
    17 00000027 CD41                <1>     int 41h
    18                              <1> .noPrint:
    19 00000029 B8FF4C0000          <1>     mov eax, 4CFFh
    20 0000002E CD41                <1>     int 41h
    21                              <1> okVersion:
    22                              <1> ;Initialise the BSS and to 0
    23 00000030 488D3D(00000000)    <1>     lea rdi, section..bss.start
    24 00000037 48B956030000000000- <1>     mov rcx, bssLen
    24 00000040 00                  <1>
    25 00000041 31C0                <1>     xor eax, eax
    26 00000043 F3AA                <1>     rep stosb
    27                              <1> ;One command line argument except for mandatory filename, /B=(binary read)
    28 00000045 B800370000          <1>     mov eax, 3700h
    29 0000004A CD41                <1>     int 41h
    30 0000004C 88D7                <1>     mov bh, dl  ;Preserve switch char in bh
    31                              <1> 
    32 0000004E B801610000          <1>     mov eax, 6101h  ;Get parsed FCB and cmdtail for filename in rdx
    33 00000053 CD41                <1>     int 41h
    34                              <1> ;Now parse the command line, to get full command spec for filename.
    35 00000055 488D7A25            <1>     lea rdi, qword [rdx + cmdArgs.progTail] ;Get ptr to tail
    36 00000059 0FB64A24            <1>     movzx ecx, byte [rdx + cmdArgs.parmList]    ;Get number of chars in cmdline
    37 0000005D 488D15(4F000000)    <1>     lea rdx, badNameStr ;Prep for error message
    38 00000064 B020                <1>     mov al, SPC ;Now we search for a space. No leading spaces on cmdine
    39 00000066 F2AE                <1>     repne scasb
    40 00000068 85C9                <1>     test ecx, ecx   ;If no chars left (even on equality with SPC) fail
    41 0000006A 74B1                <1>     jz short badExitMsg
    42 0000006C F3AE                <1>     repe scasb  ;Now skip the spaces
    43 0000006E 85C9                <1>     test ecx, ecx   ;If we run out of chars, fail as no filename
    44 00000070 74AB                <1>     jz short badExitMsg
    45 00000072 48FFCF              <1>     dec rdi ;Point rdi to the start of the filename as given
    46 00000075 48893D(1F000000)    <1>     mov qword [tmpNamePtr], rdi    ;Save the ptr to the filename
    47 0000007C 48FFC7              <1>     inc rdi ;Go back where it was
    48 0000007F 4889FE              <1>     mov rsi, rdi
    49                              <1> .findEndLoop:
    50 00000082 AC                  <1>     lodsb
    51 00000083 3C20                <1>     cmp al, SPC
    52 00000085 740A                <1>     je short .endFoundSpc
    53 00000087 3C0D                <1>     cmp al, CR
    54 00000089 7426                <1>     je short .endFound
    55 0000008B FFC9                <1>     dec ecx
    56 0000008D 748E                <1>     jz short badExitMsg
    57 0000008F EBF1                <1>     jmp short .findEndLoop  ;Keep looking for the end of the string
    58                              <1> .endFoundSpc:
    59                              <1> ;If a space found now search for a switch, continue decrementing ecx
    60 00000091 4889F7              <1>     mov rdi, rsi    ;Points at first char past CR/SPC terminator
    61 00000094 88F8                <1>     mov al, bh  ;Get the switch char back
    62 00000096 F2AE                <1>     repne scasb   ;Search for switchChar, modify rdi
    63 00000098 7517                <1>     jne short .endFound ;If we come out here and no switchchar found, exit check
    64 0000009A 803F42              <1>     cmp byte [rdi], "B" ;Was the char after the switchChar a B (binary mode)?
    65 0000009D 488D15(EB000000)    <1>     lea rdx, badParm
    66 000000A4 0F8573FFFFFF        <1>     jne badExitMsg  ;If not, exit
    67 000000AA C605(01000000)FF    <1>     mov byte [noEofCheck], -1   ;Else, set the flag
    68                              <1> .endFound:
    69 000000B1 48FFCE              <1>     dec rsi ;Move rsi back to the terminating char
    70 000000B4 31C0                <1>     xor eax, eax
    71 000000B6 8806                <1>     mov byte [rsi], al  ;Store terminating NULL
    72                              <1> ;Now check if the drive is specified that it is valid
    73 000000B8 488B35(1F000000)    <1>     mov rsi, qword [tmpNamePtr]
    74 000000BF 668B06              <1>     mov ax, word [rsi]  ;Get the first two chars of file name
    75 000000C2 80FC3A              <1>     cmp ah, ":"
    76 000000C5 7510                <1>     jne short .noDriveSpecified
    77                              <1>     ;Check if drive specified is OK, bl has signature
    78 000000C7 488D15(35000000)    <1>     lea rdx, badDrvStr
    79 000000CE 80FBFF              <1>     cmp bl, -1
    80 000000D1 0F8446FFFFFF        <1>     je badExitMsg
    81                              <1> .noDriveSpecified:
    82                              <1> ;Now we canonicalise the filename since now it is ASCIIZ
    83 000000D7 488D3D(43000000)    <1>     lea rdi, pathspec
    84 000000DE B800600000          <1>     mov eax, 6000h  ;Truename the path in rsi to rdi
    85 000000E3 CD41                <1>     int 41h
    86                              <1>     ;Now get a pointer to the file name and file extension
    87 000000E5 B944000000          <1>     mov ecx, 68
    88 000000EA 31C0                <1>     xor eax, eax    ;Find the null terminator
    89 000000EC F2AE                <1>     repne scasb
    90 000000EE 67E368              <1>     jecxz .badPathError
    91 000000F1 B05C                <1>     mov al, "\"     ;Find the first pathsep backwards
    92 000000F3 B90E000000          <1>     mov ecx, 14
    93 000000F8 FD                  <1>     std
    94 000000F9 F2AE                <1>     repne scasb
    95 000000FB FC                  <1>     cld
    96 000000FC 67E35A              <1>     jecxz .badPathError
    97 000000FF 4881C702000000      <1>     add rdi, 2 ;Point to the first char in the filename
    98 00000106 48893D(1F000000)    <1>     mov qword [fileNamePtr], rdi
    99 0000010D 4889FE              <1>     mov rsi, rdi
   100                              <1>     ; Now find the extension (or add one if no extension)
   101                              <1> .extSearch:
   102                              <1> ;Keep searching for . or NUL in filename portion of path
   103 00000110 AC                  <1>     lodsb
   104 00000111 3C2E                <1>     cmp al, "."
   105 00000113 741C                <1>     je short .extFnd
   106 00000115 84C0                <1>     test al, al
   107 00000117 75F7                <1>     jnz short .extSearch
   108                              <1> ;No extension found, add one made of spaces
   109 00000119 48FFCE              <1>     dec rsi ;Point rdi back at the null char
   110 0000011C 488935(27000000)    <1>     mov qword [fileExtPtr], rsi
   111 00000123 4889F7              <1>     mov rdi, rsi
   112 00000126 B82E202020          <1>     mov eax, ".   "    ;dot and three spaces (obviously)
   113 0000012B AB                  <1>     stosd
   114 0000012C 31C0                <1>     xor eax, eax
   115 0000012E AA                  <1>     stosb
   116 0000012F EB34                <1>     jmp short .pathComplete
   117                              <1> .extFnd:
   118                              <1> ;rsi points to the first char of the extension (not the dot)
   119 00000131 48FFCE              <1>     dec rsi
   120 00000134 488935(27000000)    <1>     mov qword [fileExtPtr], rsi
   121 0000013B 48FFC6              <1>     inc rsi ;Go back to the first char past the dot
   122 0000013E 4889F7              <1>     mov rdi, rsi
   123 00000141 B903000000          <1>     mov ecx, 3  ;Three chars in the extension
   124 00000146 31C0                <1>     xor eax, eax
   125 00000148 F2AE                <1>     repne scasb   ;Look for the terminating null
   126 0000014A 67E318              <1>     jecxz .pathComplete ;Already a three char extension
   127 0000014D 48FFCF              <1>     dec rdi ;Go back to terminating null and overwrite it
   128 00000150 B020                <1>     mov al, " "
   129 00000152 F3AA                <1>     rep stosb   ;Store the number of remaining spaces
   130 00000154 31C0                <1>     xor eax, eax
   131 00000156 AA                  <1>     stosb
   132 00000157 EB0C                <1>     jmp short .pathComplete
   133                              <1> .badPathError:
   134 00000159 488D15(C9000000)    <1>     lea rdx, badFileStr
   135 00000160 E9B8FEFFFF          <1>     jmp badExitMsg
   136                              <1> .pathComplete:
   137                              <1> ;Paths can only be a max of 67 chars but the DTA buffer is 127 bytes
   138                              <1> ; so if no extension is provided or too short an extension is provided,
   139                              <1> ; simply add space for the extension.
   140                              <1> 
   141                              <1> ;Now realloc memory. No need to add the extra paragraph, but we 
   142                              <1> ; do so for as to protect the top of stack from enemy programs 
   143                              <1> ; with "segfault-ish" behaviour
   144 00000165 488D25(40060000)    <1>     lea rsp, stackTop
   145 0000016C 488D1D(40060000)    <1>     lea rbx, endOfProgram   ;Guaranteed paragraph alignment
   146 00000173 4C29C3              <1>     sub rbx, r8 ;Get number of bytes in block
   147 00000176 48C1EB04            <1>     shr rbx, 4  ;Convert to paragraphs
   148 0000017A 48FFC3              <1>     inc rbx     ;Add one more paragraph for good measure
   149 0000017D B8004A0000          <1>     mov eax, 4A00h
   150 00000182 CD41                <1>     int 41h
   151 00000184 488D15(0D010000)    <1>     lea rdx, badRealloc
   152 0000018B 0F828CFEFFFF        <1>     jc badExitMsg
   153                              <1> ;Now we proceed with opening the file/creating if it is new.
   154                              <1> fileSearch:
   155 00000191 4889FA              <1>     mov rdx, rdi    ;Get the file name pointer
   156 00000194 B927000000          <1>     mov ecx, 27h    ;Inclusive search (Archive, System, Hidden, Read-Only)
   157 00000199 B8004E0000          <1>     mov eax, 4E00h  ;Find the file!
   158 0000019E CD41                <1>     int 41h
   159 000001A0 732D                <1>     jnc short .fileExists
   160 000001A2 3C02                <1>     cmp al, errFnf
   161 000001A4 740C                <1>     je short .createFile
   162 000001A6 488D15(8C000000)    <1>     lea rdx, badOpenStr
   163 000001AD E96BFEFFFF          <1>     jmp badExitMsg
   164                              <1> .createFile:
   165                              <1> ;If we are creating the file, its a new file.
   166                              <1> ;Set variables appropriately.
   167 000001B2 B8003C0000          <1>     mov eax, 3C00h  ;Create file
   168 000001B7 31C9                <1>     xor ecx, ecx    ;Regular attributes
   169 000001B9 CD41                <1>     int 41h
   170 000001BB 488D15(6D000000)    <1>     lea rdx, badCreatStr
   171 000001C2 0F8255FEFFFF        <1>     jc badExitMsg
   172 000001C8 668905(2F000000)    <1>     mov word [fileHdl], ax
   173                              <1> 
   174                              <1> .fileExists:
   175                              <1> ;If we are here, we are opening the file.
   176 000001CF B8002F0000          <1>     mov eax, 2F00h
   177 000001D4 CD41                <1>     int 41h     ;Get DTA pointer in rbx
   178 000001D6 8A4B15              <1>     mov cl, byte [rbx + ffBlock.attribFnd]
   179 000001D9 488D15(A9000000)    <1>     lea rdx, badDirStr
   180 000001E0 F6C110              <1>     test cl, fileDir    ;Is dir bit set?
   181 000001E3 0F8534FEFFFF        <1>     jnz badExitMsg
   182 000001E9 31C0                <1>     xor eax, eax
   183 000001EB 31DB                <1>     xor ebx, ebx
   184 000001ED FFCB                <1>     dec ebx
   185 000001EF F6C101              <1>     test cl, fileRO      ;Is the RO bit set?
   186 000001F2 0F45C3              <1>     cmovnz eax, ebx ;Move -1 into al if RO bit set
   187 000001F5 8805(00000000)      <1>     mov byte [roFlag], al   ;Set the ro flag appropriately
   188                              <1> 
   189                              <1> 
   190                              <1> mainLoop:
   191                              <1> 
   192                              <1> 
   193                              <1> exitOk:
   194                              <1> ;Let DOS take care of freeing all resources
   195 000001FB B8004C0000          <1>     mov eax, 4C00h
   196 00000200 CD41                <1>     int 41h
   197                              <1> 
   198                              <1> 
    31                                  %include "./Source/edutils.asm"
     1                              <1> ;Utility functions for edlin go here
     2                              <1> 
     3                              <1> strlen:
     4                              <1> ;String length based on terminator in al
     5                              <1> ;Input: rsi -> Source Ptr
     6                              <1> ;       al = Terminating char to search for
     7                              <1> ;Output: ecx = Number of chars i nstring including terminator
     8 00000202 31C9                <1>     xor ecx, ecx
     9 00000204 FFC9                <1>     dec ecx
    10 00000206 57                  <1>     push rdi
    11 00000207 4889F7              <1>     mov rdi, rsi
    12 0000020A F2AE                <1>     repne scasb
    13 0000020C 5F                  <1>     pop rdi
    14 0000020D F7D9                <1>     neg ecx ;Take 2's compliment to get number of chars including terminator
    15                              <1>     return
    13                              <2> %%_ret:
    14 0000020F C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    16                              <1> 
    17                              <1> strcpy:
    18                              <1> ;Copies a string from one buffer to another
    19                              <1> ;Input: rsi -> Source Ptr
    20                              <1> ;       rdi -> Destination Ptr
    21 00000210 56                  <1>     push rsi
    22 00000211 57                  <1>     push rdi
    23 00000212 51                  <1>     push rcx
    24 00000213 B9FD000000          <1>     mov ecx, lineLen    ;Max number of chars in a string
    25                              <1> .lp:
    26 00000218 E830000000          <1>     call isCharEOL
    27 0000021D 7405                <1>     je short .exit
    28 0000021F A4                  <1>     movsb   ;Move the char over, inc both pointers
    29 00000220 FFC9                <1>     dec ecx
    30 00000222 75F4                <1>     jnz short .lp
    31                              <1> .exit:
    32 00000224 59                  <1>     pop rcx
    33 00000225 5F                  <1>     pop rdi
    34 00000226 5E                  <1>     pop rsi
    35                              <1>     return
    13                              <2> %%_ret:
    14 00000227 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    36                              <1> 
    37                              <1> memmove:
    38                              <1> ;Copies a number of bytes over from one buffer to another
    39                              <1> ;Input: rsi -> Source Ptr
    40                              <1> ;       rdi -> Destination Ptr
    41                              <1> ;       ecx = Count of chars to copy
    42 00000228 56                  <1>     push rsi
    43 00000229 57                  <1>     push rdi
    44 0000022A 51                  <1>     push rcx
    45 0000022B F3A4                <1>     rep movsb
    46 0000022D 59                  <1>     pop rcx
    47 0000022E 5F                  <1>     pop rdi
    48 0000022F 5E                  <1>     pop rsi
    49                              <1>     return
    13                              <2> %%_ret:
    14 00000230 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    50                              <1> 
    51                              <1> memset:
    52                              <1> ;Initialises a buffer to contain a particular value
    53                              <1> ;Input: rdi -> Buffer to set to given value
    54                              <1> ;       al = Value to set the buffer to
    55                              <1> ;       rcx = Number of bytes in buffer
    56 00000231 51                  <1>     push rcx
    57 00000232 57                  <1>     push rdi
    58 00000233 F3AA                <1>     rep stosb
    59 00000235 5F                  <1>     pop rdi
    60 00000236 59                  <1>     pop rcx
    61                              <1>     return
    13                              <2> %%_ret:
    14 00000237 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    62                              <1> 
    63                              <1> findLineEnd:
    64                              <1> ;Returns in rsi a pointer to the end of the line
    65                              <1> ;Input: rsi -> Start of the line find the end of
    66                              <1> ;Output: rsi -> Last char in the string (NOTE: LAST CHAR NOT PAST)
    67                              <1> ;Trashes: rcx
    68 00000238 B9FD000000          <1>     mov ecx, lineLen
    69                              <1> .lp:
    70 0000023D E80B000000          <1>     call isCharEOL  ;If ZF=ZE, then rsi points to EOL
    71                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000242 74(37)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    72 00000244 FFC9                <1>     dec ecx
    73                              <1>     retz    ;If ecx is now 0, means rsi points to the end of line (NO EOL CHAR)
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000246 74(37)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    74 00000248 48FFC6              <1>     inc rsi
    75 0000024B EBF0                <1>     jmp short .lp
    76                              <1> 
    77                              <1> isCharEOL:
    78                              <1> ;Input: rsi -> Char/Word to analyse
    79                              <1> ;Output: ZF=ZE if char/word at rsi LF or CR,LF.
    80                              <1> ;        ZF=NZ if not
    81 0000024D E811000000          <1>     call isCharEOF
    82                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000252 74(37)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    83 00000254 803E0A              <1>     cmp byte [rsi], LF
    84                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000257 74(37)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    85 00000259 803E0D              <1>     cmp byte [rsi], CR
    86                              <1>     retne
    53                              <2> cret ne
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 0000025C 75(37)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    87 0000025E 807E010A            <1>     cmp byte [rsi + 1], LF
    88                              <1>     return
    13                              <2> %%_ret:
    14 00000262 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    89                              <1> 
    90                              <1> isCharEOF:
    91                              <1> ;Input: rsi -> Char to check if it is ^Z
    92                              <1> ;Output: ZF=ZE if char at rsi is ^Z AND we are checking for EOFs
    93                              <1> ;        ZF=NZ if char at rsi is not ^Z or we are not checking for eof's
    94 00000263 50                  <1>     push rax
    95 00000264 8A05(01000000)      <1>     mov al, byte [noEofCheck]
    96 0000026A F6D0                <1>     not al  ;Invert the bits (1's compliment)
    97 0000026C 58                  <1>     pop rax
    98                              <1>     retnz   ;Return if not checking for EOF
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 0000026D 75(62)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    99 0000026F 803E1A              <1>     cmp byte [rsi], EOF ;Check if eof
   100                              <1>     return
    13                              <2> %%_ret:
    14 00000272 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   101                              <1> 
    32                                  Segment .data align=1 follows=.text 
    33                                  %include "./Data/eddata.asm"
    34                                  %include "./Data/edmsg.asm"
     1                              <1> ;Edlin Strings are in this file
     2 00000000 4E65772066696C65    <1> newStr  db "New file"   ;This string is terminated by the next line
     3 00000008 0D0A24              <1> crlf    db CR,LF,"$"
     4 0000000B 456E64206F6620696E- <1> eofStr  db "End of input file",CR,LF,"$"    ;When EOF occurs
     4 00000014 7075742066696C650D- <1>
     4 0000001D 0A24                <1>
     5 0000001F 496E76616C69642044- <1> badVerStr   db "Invalid DOS Version",CR,LF,"$"
     5 00000028 4F532056657273696F- <1>
     5 00000031 6E0D0A24            <1>
     6 00000035 496E76616C69642044- <1> badDrvStr   db "Invalid Drive Specified",CR,LF,"$"
     6 0000003E 726976652053706563- <1>
     6 00000047 69666965640D0A24    <1>
     7 0000004F 46696C65206E616D65- <1> badNameStr  db "File name must be specified",CR,LF,"$"
     7 00000058 206D75737420626520- <1>
     7 00000061 737065636966696564- <1>
     7 0000006A 0D0A24              <1>
     8 0000006D 43616E6E6F74206372- <1> badCreatStr db "Cannot create specified file",CR,LF,"$"
     8 00000076 656174652073706563- <1>
     8 0000007F 69666965642066696C- <1>
     8 00000088 650D0A24            <1>
     9 0000008C 43616E6E6F74206F70- <1> badOpenStr  db "Cannot open specified file",CR,LF,"$"
     9 00000095 656E20737065636966- <1>
     9 0000009E 6965642066696C650D- <1>
     9 000000A7 0A24                <1>
    10 000000A9 43616E6E6F74206F70- <1> badDirStr   db "Cannot open directory to edit",CR,LF,"$"
    10 000000B2 656E20646972656374- <1>
    10 000000BB 6F727920746F206564- <1>
    10 000000C4 69740D0A24          <1>
    11 000000C9 43616E6E6F74207061- <1> badFileStr  db "Cannot parse sepcified filespec",CR,LF,"$"
    11 000000D2 727365207365706369- <1>
    11 000000DB 666965642066696C65- <1>
    11 000000E4 737065630D0A24      <1>
    12 000000EB 496E76616C69642050- <1> badParm     db "Invalid Parameter",CR,LF,"$"
    12 000000F4 6172616D657465720D- <1>
    12 000000FD 0A24                <1>
    13 000000FF 456E74727920657272- <1> badInput    db "Entry error",CR,LF,"$"
    13 00000108 6F720D0A24          <1>
    14 0000010D 5265616C6C6F636174- <1> badRealloc  db "Reallocation error",CR,LF,"$"
    14 00000116 696F6E206572726F72- <1>
    14 0000011F 0D0A24              <1>
    15 00000122 0D0A2A24            <1> prompt      db CR,LF,"*$"
    35                                  Segment .bss align=1 follows=.data nobits
    36                                  bssStart:
    37                                  %include "./Data/edbss.asm"
     1                              <1> 
     2                              <1> ;All variables that dont need initialisation go here
     3 00000000 ??                  <1> roFlag      db ?    ;Flag is set if file is read-only. Cannot edit the file.
     4 00000001 ??                  <1> noEofCheck  db ?    ;Flag is set if we are not to check for ^Z chars found in the file
     5 00000002 ??                  <1> eofReached  db ?    ;When we reach EOF for file, set to -1, else 0
     6                              <1> 
     7                              <1> ;Treat line numbers as dwords even though they are words
     8 00000003 ????????????????    <1> memPtr      dq ?    ;Ptr to the memory arena given by DOS
     9 0000000B ????????            <1> arenaSize   dd ?    ;Size of the arena
    10 0000000F ????????            <1> memInUse    dd ?    ;Number of bytes in use
    11                              <1> ;If arenaSize = memInUse, refuse any "extensionary" instructions.
    12                              <1> ; Allow searching, editing, flushing, editing up to equal
    13                              <1> ; number of chars in line.
    14                              <1> 
    15 00000013 ????????????????    <1> linePtr     dq ?    ;Ptr to the current source line in memory
    16 0000001B ????????            <1> lastLine    dd ?    ;Last line number currently in memory
    17                              <1> 
    18                              <1> 
    19                              <1> tmpNamePtr:
    20 0000001F ????????????????    <1> fileNamePtr dq ?    ;Ptr to the name portion of filespec
    21 00000027 ????????????????    <1> fileExtPtr  dq ?    ;Ptr to the extension of the file we are editing
    22 0000002F ????                <1> fileHdl     dw ?    ;Contain the file handle for the open file
    23 00000031 ????                <1> bkupHdl     dw ?    ;Handle to the backup file
    24                              <1> 
    25 00000033 <res 10h>           <1> tmpName     db 16 dup (?)   ;Space for the ASCIIZ path for tmp name.
    26                              <1> ;                              names of the form ".\12345678.ext",0
    27 00000043 <res 80h>           <1> pathspec    db 128 dup (?)  ;Space for the 128 byte buffer for full filename
    28 000000C3 <res 80h>           <1> pathspec2   db 128 dup (?)  ;Second pathspec space
    29 00000143 ????????            <1> bkupExt     db 4 dup (?)    ;A backup for a .EXT to be used (dot included!!!)
    30                              <1> 
    31                              <1> ;Command line variables
    32 00000147 <res 82h>           <1> cmdLine     db halfLine_size dup (?)
    33 000001C9 ??                  <1> args        db ?    ;Count of arguments in parsed command line
    34 000001CA ??                  <1> cmdChar     db ?
    35                              <1> ;Arguments are converted to signed words where appropriate
    36                              <1> ; and parsed into here in the order they are encountered in.
    37                              <1> ;
    38 000001CB ????                <1> arg1        dw ?
    39 000001CD ????                <1> arg2        dw ?
    40 000001CF ????                <1> arg3        dw ?
    41 000001D1 ????                <1> arg4        dw ?
    42 000001D3 <res 82h>           <1> argString   db halfLine_size dup (?)    ;Used by search and replace only
    43 00000255 ??                  <1> argPastEnd  db ?    ;0 -> normal, -1 -> Offset from end of mem (indicated by #)
    44                              <1> 
    45                              <1> ;The editLine gets preloaded with the original line before editing
    46                              <1> ;editLine has type "line"
    47 00000256 <res 100h>          <1> editLine    db 256 dup (?)  ;Line in which all editing takes place
    38                                  bssLen equ ($ - bssStart)
    39                                  Segment .stack align=16 follows=.bss nobits
    40                                  ;Use a 200 QWORD stack
    41 00000000 <res 640h>                  dq 200 dup (?)
    42                                  stackTop:
    43                                  endOfProgram:   ;Deallocate from here
    43          ------------------       info: assembly required 1+2+2 passes

