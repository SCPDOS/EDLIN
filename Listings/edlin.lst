     1                                  [map all ./Listings/edlin.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  ;EDLIN, an absolute last resort file editor.
     5                                  ;
     6                                  ;                       !!DONT FORGET!!
     7                                  ;       Each line is terminated first with 0Dh then 0Ah (CR,LF)
     8                                  ;                       !!DONT FORGET!!
     9                                  ;
    10                                  
    11                                  ;Edlin will always produce a backup file and refuses to open files 
    12                                  ; with .BAK extension (backup files)
    13                                  
    14                                  ;Edlin will always terminate a file with a single EOF character
    15                                  
    16                                  ;Edlin will erase the previous backup if one exists, ensuring there
    17                                  ; is enough free space for a new copy of the backup.
    18                                  ;It then creates a new file with the filename with a $$$ extension.
    19                                  ;All edits occur in memory and are flushed to it. We then rename it
    20                                  ; to the desired filename.
    21                                  ;BAK files cannot be opened.
    22                                  ;
    23                                  ;Empty lines are default just a CR,LF pair
    24                                  
    25                                  ;Edlin has two modes of operation: Command and Edit
    26                                  
    27                                  %include "./Include/dosMacro.mac"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------------------------------
     3                              <1> ;Generic Macros file
     4                              <1> ;The following instruction extensions allow to conditionally return
     5                              <1> ;The idea was borrowed from the DOS Source Code
     6                              <1> ;
     7                              <1> ;-------------------------------------------------------------------------------
     8                              <1> 
     9                              <1> ;-------------------------------------------------------------------------------
    10                              <1> ;These macros are live and must not be touched
    11                              <1> ;-------------------------------------------------------------------------------
    12                              <1> %macro return 0
    13                              <1> %%_ret:
    14                              <1>     ret
    15                              <1> %assign retOff %%_ret-$$  ;Get offset into segment of %%_ret
    16                              <1> %endmacro
    17                              <1> 
    18                              <1> %macro cret 1
    19                              <1> %%_base:
    20                              <1> %assign baseVar %%_base-$$ ;Get offset into segment of %%_base
    21                              <1>     %ifdef retOff
    22                              <1>     %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <1>     %ifdef currSegVBase
    24                              <1>     j%+1 short (retOff+currSegVBase)
    25                              <1>     %else
    26                              <1>     j%+1 short retOff
    27                              <1>     %endif  ;End ifdef currSegVBase
    28                              <1>     %else 
    29                              <1>     j%-1 short %%a
    30                              <1>     return
    31                              <1> %%a:
    32                              <1>     %endif  ;End the distance measurement if
    33                              <1>     %else   
    34                              <1>     j%-1 short %%a
    35                              <1>     return
    36                              <1> %%a:
    37                              <1>     %endif  ;End ifdef retoff
    38                              <1> %endmacro
    39                              <1> 
    40                              <1> %macro retz 0
    41                              <1> cret z
    42                              <1> %endmacro
    43                              <1> 
    44                              <1> %macro retnz 0
    45                              <1> cret nz
    46                              <1> %endmacro
    47                              <1> 
    48                              <1> %macro rete 0
    49                              <1> cret e
    50                              <1> %endmacro
    51                              <1> 
    52                              <1> %macro retne 0
    53                              <1> cret ne
    54                              <1> %endmacro
    55                              <1> 
    56                              <1> %macro retc 0
    57                              <1> cret c
    58                              <1> %endmacro
    59                              <1> 
    60                              <1> %macro retnc 0
    61                              <1> cret nc
    62                              <1> %endmacro
    63                              <1> 
    64                              <1> %macro retb 0
    65                              <1> cret b
    66                              <1> %endmacro
    67                              <1> 
    68                              <1> %macro retnb 0
    69                              <1> cret nb
    70                              <1> %endmacro
    71                              <1> 
    72                              <1> %macro reta 0
    73                              <1> cret a
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> %macro retna 0
    77                              <1> cret na
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro retbe 0
    81                              <1> cret be
    82                              <1> %endmacro
    83                              <1> 
    84                              <1> %macro retae 0
    85                              <1> cret ae
    86                              <1> %endmacro
    87                              <1> 
    88                              <1> %macro breakpoint 0
    89                              <1> xchg bx, bx
    90                              <1> %endmacro
    91                              <1> 
    92                              <1> ;A macro for returning to dos
    93                              <1> %macro retToDOS 1
    94                              <1>     mov eax, 04C00h | %1
    95                              <1>     int 21h
    96                              <1> %endmacro
    28                                  %include "./Include/dosError.inc"
     1                              <1> ;DOS Error codes
     2                              <1> 
     3                              <1> ;Extended Error Codes
     4                              <1> errInvFnc   equ 1   ;Invalid function number
     5                              <1> errFnf      equ 2   ;File not found
     6                              <1> errPnf      equ 3   ;Path not found
     7                              <1> errNhl      equ 4   ;Too many open handles, no handles left
     8                              <1> errAccDen   equ 5   ;Access denied (to resource)
     9                              <1> errBadHdl   equ 6   ;Invalid handle
    10                              <1> errMCBbad   equ 7   ;MCB's destroyed
    11                              <1> errNoMem    equ 8   ;Insufficient memory
    12                              <1> errMemAddr  equ 9   ;Invalid Memory Block Address
    13                              <1> errBadEnv   equ 10  ;Invalid environment
    14                              <1> errBadFmt   equ 11  ;Invalid format (path etc)
    15                              <1> errAccCde   equ 12  ;Invalid Access Code    ?
    16                              <1> errInvDat   equ 13  ;Invalid data
    17                              <1> ;           equ 14  ;Reserved
    18                              <1> errBadDrv   equ 15  ;Invalid drive specified
    19                              <1> errDelCD    equ 16  ;Attempt to delete the current directory
    20                              <1> errDevUnk   equ 17  ;Not the same device (Device Unknown)
    21                              <1> errNoFil    equ 18  ;No more files, no match found
    22                              <1> ;The following are Driver error codes + 19
    23                              <1> drvErrShft  equ 19  ;Used to shift Driver error codes to extended error codes
    24                              <1> errWpd      equ 19  ;Attempt to write on write protected disk
    25                              <1> errUnkUnt   equ 20  ;Unknown Unit
    26                              <1> errDrvNR    equ 21  ;Drive not ready
    27                              <1> errUnkCmd   equ 22  ;Unknown Command
    28                              <1> errCRCerr   equ 23  ;Data (CRC) error
    29                              <1> errBadRLn   equ 24  ;Bad request structure length
    30                              <1> errSekErr   equ 25  ;Seek error
    31                              <1> errUnkMed   equ 26  ;Unknown media type
    32                              <1> errSecNF    equ 27  ;Sector not Found
    33                              <1> errNoPap    equ 28  ;Printer out of paper
    34                              <1> errWF       equ 29  ;Write fault
    35                              <1> errRF       equ 30  ;Read fault
    36                              <1> errGF       equ 31  ;General fault
    37                              <1> ;----------------------------------------------
    38                              <1> ;The following two go inbetween the Disk errors
    39                              <1> errShrVio   equ 32  ;Sharing violations
    40                              <1> errLokVio   equ 33  ;File Lock violation
    41                              <1> ;----------------------------------------------
    42                              <1> errIDC      equ 34  ;Driver code, Invalid Disk Change
    43                              <1> errNoFCB    equ 35  ;FCB unavailable
    44                              <1> errShrFul   equ 36  ;Sharing buffer full
    45                              <1> 
    46                              <1> errNoNet    equ 50  ;Network request not supported, generic net fail
    47                              <1> 
    48                              <1> errFilExist equ 80  ;File already exists
    49                              <1> errDirExist equ 82  ;Directory already exists
    50                              <1> errFI44     equ 83  ;Fail on Int 24h
    51                              <1> errRedir    equ 84  ;Too many levels of redirection
    52                              <1> errDupRedir equ 85  ;Trying to redirect a redirection
    53                              <1> errBadPass  equ 86  ;Bad password
    54                              <1> errBadParam equ 87  ;Bad parameter passed to request
    55                              <1> errNetWrite equ 88  ;Network Write Fault
    56                              <1> ;-----------------------------------------------------------------------------
    57                              <1> ;Error Loci
    58                              <1> eLocUnk     equ 1   ;Unknown locus, nonspecific or not appropriate
    59                              <1> eLocDsk     equ 2   ;Disk, related to Random Access to a disk or block device
    60                              <1> eLocNet     equ 3   ;Network related issues, shouldnt affect us (yet!)
    61                              <1> eLocChr     equ 4   ;Serial/Character Device error
    62                              <1> eLocMem     equ 5   ;Related to RAM
    63                              <1> ;-----------------------------------------------------------------------------
    64                              <1> ;Error Actions
    65                              <1> eActRet     equ 1   ;Retry
    66                              <1> eActDRet    equ 2   ;Delay then retry (Try again later)
    67                              <1> eActUsr     equ 3   ;Ask user to re-input data, i.e. bad filename or something
    68                              <1> eActAbt     equ 4   ;Abort with cleanup
    69                              <1> eActKil     equ 5   ;Abort without cleanup
    70                              <1> eActIgn     equ 6   ;Ignore error
    71                              <1> eActRetUsr  equ 7   ;Retry after user intervention (i.e swap remdev)
    72                              <1> ;-----------------------------------------------------------------------------
    73                              <1> ;Error classes
    74                              <1> eClsOoR     equ 1   ;Out of resources, no mem or handles
    75                              <1> eClsTS      equ 2   ;Temp sitch, should go away
    76                              <1> eClsAuth    equ 3   ;Authorisation, e.g. file permission error 
    77                              <1> eClsInt     equ 4   ;Internal DOS error or bug
    78                              <1> eClsHrdFlt  equ 5   ;Hardware Failure
    79                              <1> eClsSysFlt  equ 6   ;System Failure, i.e. missing or bad cfg files
    80                              <1> eClsAppFlt  equ 7   ;Application Program error, inconsistent requests etc...
    81                              <1> eClsNotFnd  equ 8   ;Resource not found (such as free SFT entry etc...)
    82                              <1> eClsBadFmt  equ 9   ;Bad format for resource
    83                              <1> eClsLocked  equ 10  ;Resource Locked
    84                              <1> eClsMedia   equ 11  ;Error is on medium, i.e. wrong or damaged remdev
    85                              <1> eClsClash   equ 12  ;Resource already exists!
    86                              <1> eClsUnk     equ 13  ;Unknown class
    29                                  %include "./Include/edError.inc"
     1                              <1> ;Edlin specific errors
     2                              <1> 
     3                              <1> errOk       equ 0
     4                              <1> errBadRen   equ 1   ;Couldn't rename files.
     5                              <1> errDskFull  equ 2   ;Disk full.
     6                              <1> errBadRead  equ 3   ;Couldn't move file pointer or read file in append
     7                              <1> errBadBak   equ 4   ;Couldn't delete backup file
     8                              <1> errCharDev  equ 5   ;Tried to open a character device for editing!!
    30                                  %include "./Include/edStruc.inc"
     1                              <1> ;edlin structures
     2                              <1> lineLen     equ 253
     3                              <1> halflineLen equ 128
     4                              <1> maxLine     equ 65529
     5                              <1> maxAlloc    equ maxLine*lineLen
     6                              <1> maxParas    equ (maxAlloc >> 4) + 1
     7                              <1> 
     8                              <1> prompt      equ "*"
     9                              <1> 
    10                              <1> ;Bona-Fida Structures
    11                              <1> 
    12                              <1> struc line
    13 00000000 ??                  <1>     .bBufLen    db ?    ;Buffer size (255)
    14 00000001 ??                  <1>     .bStrLen    db ?    ;Length of the string entered in buffer
    15 00000002 <res FDh>           <1>     .pString    db lineLen dup (?)      ;Actual string itself
    16                              <1> endstruc
    17                              <1> 
    18                              <1> struc halfLine
    19 00000000 ??                  <1>     .bBufLen    db ?    ;Buffer size (130)
    20 00000001 ??                  <1>     .bStrLen    db ?    ;Length of the string entered in buffer
    21 00000002 <res 80h>           <1>     .pString    db halflineLen dup (?)   ;Actual string itself
    22                              <1> endstruc
    23                              <1> 
    24                              <1> struc filename
    25                              <1> ;8.3 File name struct
    26 00000000 ????????????????    <1>     .fName  resb 8
    27 00000008 ??????              <1>     .fExt   resb 3
    28                              <1> endstruc
    31                                  %include "./Include/dosStruc.inc"
     1                              <1> ;Structures and equates coming from DOS
     2                              <1> 
     3                              <1> ;MISC ASCII control chars
     4                              <1> NUL equ 00h ;^@         | ASCII Null
     5                              <1> ETX equ 03h ;^C         | ASCII Break (End of Text)
     6                              <1> ACK equ 06h ;^F         | ASCII Acknowledgement
     7                              <1> BEL equ 07h ;^G         | ASCII Bell
     8                              <1> BSP equ 08h ;^H         | ASCII Backspace
     9                              <1> TAB equ 09h ;^I         | ASCII Horizontal Tab
    10                              <1> LF  equ 0Ah ;^J         | ASCII Line Feed
    11                              <1> CR  equ 0Dh ;^M         | ASCII Carriage Return
    12                              <1> DLE equ 10h ;^P         | ASCII Data Link End (Toggle Print Echo)
    13                              <1> DC3 equ 13h ;^S         | ASCII Device Control 3 (Toggle Scroll Lock)
    14                              <1> DC4 equ 14h ;^T         | ASCII Device Control 4
    15                              <1> NAK equ 15h ;^U         | ASCII Negative Acknowledgement
    16                              <1> CMD equ 16h ;^V         | EDLIN COMMAND CHAR
    17                              <1> ETB equ 17h ;^W         | ASCII End of Transmission Block
    18                              <1> EOF equ 1Ah ;^Z         | ASCII Substitute character (End of File)
    19                              <1> ESC equ 1Bh ;           | ASCII Escape char, used for ANSI.SYS
    20                              <1> SPC equ 20h ;Printable  | ASCII Space
    21                              <1> ;This last one is NEVER printed with a caret as it is a console control char
    22                              <1> DEL equ 7Fh ;^?         | ASCII Rubout (Del char and dec cursor)
    23                              <1> 
    24                              <1> CRLF equ 0A0Dh
    25                              <1> 
    26                              <1> asciiCaret  equ 20h ;Used to check which chars need to be printed with caret
    27                              <1> asciiMask   equ asciiCaret - 1  ;Turn into a bitmask
    28                              <1> 
    29                              <1> ;Extended Ascii Codes
    30                              <1> eF1     equ 3Bh ;F1 second byte
    31                              <1> eF2     equ 3Ch ;F2 second byte
    32                              <1> eF3     equ 3Dh ;F3 second byte
    33                              <1> eF4     equ 3Eh ;F4 second byte
    34                              <1> eF5     equ 3Fh ;F5 second byte
    35                              <1> eF6     equ 40h ;F6 second byte
    36                              <1> eF7     equ 41h ;F7 second byte
    37                              <1> eCursL  equ 4Bh ;Cursor Left second byte
    38                              <1> eCursR  equ 4Dh ;Cursor Right second byte
    39                              <1> eIns    equ 52h ;Insert second byte
    40                              <1> eDel    equ 53h ;DEL second byte (not necessarily delete key)
    41                              <1> 
    42                              <1> ;Directory attribute equates
    43                              <1>     dirReadOnly     equ 01h
    44                              <1>     dirHidden       equ 02h
    45                              <1>     dirSystem       equ 04h
    46                              <1>     dirVolumeID     equ 08h
    47                              <1>     dirDirectory    equ 10h
    48                              <1>     dirArchive      equ 20h
    49                              <1>     dirCharDev      equ 40h ;Never written to disk, used to represent a Char Dev
    50                              <1>     dirLongName     equ dirReadOnly | dirHidden | dirSystem | dirVolumeID
    51                              <1>     ;If any of the three bits are set, then ALL three bits are set
    52                              <1>     ; in addition to whatever the user passed to search for.
    53                              <1>     dirInclusive    equ dirHidden | dirSystem | dirDirectory
    54                              <1>     dirIncFiles     equ dirHidden | dirSystem
    55                              <1> 
    56                              <1> struc cmdArgs   ;Ptr returned in rdx after 41h/6101h has this structure
    57 00000000 <res 10h>           <1>     .fcb1       db 16 dup (?)  ;First FCB,    argument 1
    58 00000010 <res 14h>           <1>     .fcb2       db 20 dup (?)  ;Second FCB,   argument 2
    59                              <1>     .dta:   ;Pointer to the default DTA in the
    60 00000024 ??                  <1>     .parmList   db ?   ;Number of characters in command tail
    61 00000025 <res 7Fh>           <1>     .progTail   db 127 dup (?) ;Default DTA/Program tail
    62                              <1> endstruc
    63                              <1> 
    64                              <1> struc ffBlock   ;The structure of the Find First structure at the DTA
    65 00000000 ??                  <1>     .driveNum   resb 1  ;Drive we are searching on
    66 00000001 <res Bh>            <1>     .template   resb 11 ;Search template (? meaning anything)
    67 0000000C ??                  <1>     .attrib     resb 1  ;Search attribute
    68 0000000D ????????            <1>     .dirOffset  resd 1  ;32 byte entry within dir cluster
    69 00000011 ????????            <1>     .parDirClus resd 1  ;Parent Directory Cluster number
    70 00000015 ??                  <1>     .attribFnd  resb 1  ;Attrib of file found
    71 00000016 ????                <1>     .fileTime   resw 1  ;File time
    72 00000018 ????                <1>     .fileDate   resw 1  ;File date
    73 0000001A ????????            <1>     .fileSize   resd 1  ;Number of bytes
    74 0000001E <res Dh>            <1>     .asciizName resb 13 ;ASCIIZ name with dot and terminating nul
    75                              <1> endstruc
    76                              <1> 
    77                              <1> ;Open Mode equates
    78                              <1> ;Access modes   Bits[2:0]
    79                              <1> ReadAccess      equ 0h
    80                              <1> WriteAccess     equ 1h
    81                              <1> RWAccess        equ 2h
    82                              <1> ;Bit 3 reserved 0
    83                              <1> ;Sharing modes  Bits[6:4]
    84                              <1> CompatShare     equ 0h
    85                              <1> denyRWShare     equ 10h
    86                              <1> denyWriteShare  equ 20h
    87                              <1> denyReadShare   equ 30h
    88                              <1> denyNoneShare   equ 40h
    89                              <1> netFCBShare     equ 70h
    90                              <1> noInherit       equ 80h
    32                                  Segment .text align=1 
    33                                  progHeadPtr:      ;DO NOT TOUCH THIS POINTER. ALL TABLES ARE REL THIS PTR.
    34                                  %include "./Source/edmain.asm"
     1                              <1> ;Contains the program loader
     2                              <1> start:
     3 00000000 EB01                <1>     jmp short .cVersion
     4 00000002 01                  <1> .vNum:          db 1    ;Main version number, patchable
     5                              <1> .cVersion:
     6 00000003 FC                  <1>     cld
     7 00000004 B800300000          <1>     mov eax, 3000h  ;Get version number
     8 00000009 CD21                <1>     int 21h
     9 0000000B 3A05F1FFFFFF        <1>     cmp al, byte [.vNum]
    10 00000011 760C                <1>     jbe short okVersion
    11 00000013 488D15(5B000000)    <1>     lea rdx, badVerStr
    12 0000001A E930050000          <1>     jmp badExitMsg
    13                              <1> okVersion:
    14                              <1> ;Initialise the BSS to 0
    15 0000001F 488D3D(00000000)    <1>     lea rdi, section..bss.start
    16 00000026 48B92F060000000000- <1>     mov rcx, bssLen
    16 0000002F 00                  <1>
    17 00000030 31C0                <1>     xor eax, eax
    18 00000032 F3AA                <1>     rep stosb
    19                              <1> ;Now move the stack pointer to its new position and reallocate!
    20 00000034 488D25(40060000)    <1>     lea rsp, stackTop
    21 0000003B 488D1D(40060000)    <1>     lea rbx, endOfProgram   ;Guaranteed paragraph alignment
    22 00000042 4C29C3              <1>     sub rbx, r8 ;Get number of bytes in block
    23 00000045 48C1EB04            <1>     shr rbx, 4  ;Convert to paragraphs
    24 00000049 48FFC3              <1>     inc rbx     ;Add one more paragraph for good measure
    25 0000004C B8004A0000          <1>     mov eax, 4A00h
    26 00000051 CD21                <1>     int 21h
    27 00000053 488D15(66010000)    <1>     lea rdx, badRealloc
    28 0000005A 0F82EF040000        <1>     jc badExitMsg
    29                              <1> ;One command line argument except for mandatory filename, /B=(binary read)
    30 00000060 B800370000          <1>     mov eax, 3700h
    31 00000065 CD21                <1>     int 21h
    32 00000067 B85C000000          <1>     mov eax, "\"    ;Default pathsep
    33 0000006C B92F000000          <1>     mov ecx, "/"    ;Alternative pathsep
    34 00000071 80FA2D              <1>     cmp dl, "-"     ;Is the switch char default or alternative?
    35 00000074 0F44C1              <1>     cmove eax, ecx  ;Move if alternative
    36 00000077 8815(01000000)      <1>     mov byte [switchChar], dl
    37 0000007D 8805(00000000)      <1>     mov byte [pathSep], al
    38                              <1> getCmdTail:
    39 00000083 B801610000          <1>     mov eax, 6101h  ;Get parsed FCB and cmdtail for filename in rdx
    40 00000088 CD21                <1>     int 21h
    41                              <1> ;Now parse the command line, to get full command spec for filename.
    42 0000008A 488D7225            <1>     lea rsi, qword [rdx + cmdArgs.progTail]     ;Get ptr to tail
    43 0000008E 4889D5              <1>     mov rbp, rdx        ;Save the cmdArgs ptr for use when checking drive ok
    44                              <1> cmdTailParse:
    45 00000091 E85B000000          <1>     call .skipSeps      ;Skips leading terminators
    46 00000096 3C0D                <1>     cmp al, CR          ;If al is CR, we are done!
    47 00000098 0F8496000000        <1>     je .parseComplete
    48 0000009E 3A05(01000000)      <1>     cmp al, byte [switchChar]       ;If al is a switchchar, rsi points to it!
    49 000000A4 7426                <1>     je .switchFnd
    50                              <1> ;Else it must be a file name!
    51 000000A6 48813D(3E010000)00- <1>     cmp qword [tmpNamePtr], 0
    51 000000AE 000000              <1>
    52 000000B1 7539                <1>     jnz .parseBadExit   ;If this is not empty, too many filenames specified!
    53 000000B3 488935(3E010000)    <1>     mov qword [tmpNamePtr], rsi     ;Save the pointer here :)
    54 000000BA E83E000000          <1>     call .findSep                   ;Find the end of the filename
    55 000000BF 488935(46010000)    <1>     mov qword [tmpNamePtr2], rsi    ;And save it here 
    56 000000C6 3C0D                <1>     cmp al, CR                      ;Did we terminate with a CR?
    57 000000C8 746A                <1>     je .parseComplete               ;If so, we are done!
    58 000000CA EBC5                <1>     jmp short cmdTailParse          ;Else, keep parsing!
    59                              <1> .switchFnd:
    60 000000CC 48FFC6              <1>     inc rsi                 ;Go to the char past the switch
    61 000000CF AC                  <1>     lodsb                   ;Get the switchchar itself, advance rsi
    62 000000D0 24DF                <1>     and al, ~20h            ;Clear the LC bit from the char
    63 000000D2 3C42                <1>     cmp al, "B"
    64 000000D4 7516                <1>     jne .parseBadExit
    65 000000D6 C605(04000000)FF    <1>     mov byte [noEofChar], -1   ;Set the internal flag
    66 000000DD AC                  <1>     lodsb                   ;Now do lookahead
    67 000000DE 48FFCE              <1>     dec rsi                 ;Get the char rsi is pointing to, after B
    68 000000E1 3C0D                <1>     cmp al, CR              ;If this is a CR, we are done!
    69 000000E3 744F                <1>     je .parseComplete 
    70 000000E5 E82B000000          <1>     call .isAlSep           ;Is the char after /B a sep?
    71 000000EA 74A5                <1>     jz cmdTailParse         ;If so, keep parsing
    72                              <1> .parseBadExit:              ;Else, fallthru to error
    73 000000EC E957040000          <1>     jmp badParmExit
    74                              <1> .skipSeps:
    75                              <1> ;Leaves rsi pointing to the first non-separator char
    76 000000F1 AC                  <1>     lodsb
    77 000000F2 E81E000000          <1>     call .isAlSep
    78 000000F7 74F8                <1>     jz .skipSeps
    79 000000F9 48FFCE              <1>     dec rsi     ;Always return to the char itself!
    80                              <1>     return
    13                              <2> %%_ret:
    14 000000FC C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    81                              <1> .findSep:
    82                              <1> ;Leaves rsi pointing to the first found separator char, CR or switchChar
    83                              <1> ;Input: rsi -> pathspec to find end of
    84 000000FD AC                  <1>     lodsb
    85 000000FE 3C0D                <1>     cmp al, CR
    86 00000100 740F                <1>     je .fsExit
    87 00000102 3A05(01000000)      <1>     cmp al, byte [switchChar]
    88 00000108 7407                <1>     je .fsExit
    89 0000010A E806000000          <1>     call .isAlSep
    90 0000010F 75EC                <1>     jnz .findSep
    91                              <1> .fsExit:
    92 00000111 48FFCE              <1>     dec rsi
    93                              <1>     return
    13                              <2> %%_ret:
    14 00000114 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    94                              <1> .isAlSep:
    95                              <1> ;Checks if al is a terminator char. Sets ZF if so.
    96                              <1> ;Input: al = Char to check.
    97 00000115 3C20                <1>     cmp al, SPC
    98                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000117 74(14)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    99 00000119 3C09                <1>     cmp al, TAB
   100                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 0000011B 74(14)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   101 0000011D 3C3B                <1>     cmp al, ";"
   102                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 0000011F 74(14)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   103 00000121 3C2C                <1>     cmp al, ","
   104                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000123 74(14)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   105 00000125 3C3D                <1>     cmp al, "="
   106                              <1>     return
    13                              <2> %%_ret:
    14 00000127 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   107                              <1> .nameBadExit:
   108 00000128 488D15(9E000000)    <1>     lea rdx, badNameStr
   109 0000012F E91B040000          <1>     jmp badExitMsg
   110                              <1> .parseComplete:
   111                              <1> ;Check we have a pointer to a filename AT LEAST.
   112 00000134 48813D(3E010000)00- <1>     cmp qword [tmpNamePtr], 0
   112 0000013C 000000              <1>
   113 0000013F 74E7                <1>     je .nameBadExit
   114                              <1> ;Now we copy the filename internally.
   115                              <1> nameCopy:
   116 00000141 488D3D(3E000000)    <1>     lea rdi, pathspec   ;Store in the pathspec
   117 00000148 488B35(3E010000)    <1>     mov rsi, qword [tmpNamePtr]
   118 0000014F B81A120000          <1>     mov eax, 121Ah  ;Get the file drive, advance rsi if X:
   119 00000154 CD2F                <1>     int 2Fh
   120 00000156 84C0                <1>     test al, al
   121 00000158 7509                <1>     jnz .notCurDrv
   122 0000015A B800190000          <1>     mov eax, 1900h  ;Get the current drive in al
   123 0000015F CD21                <1>     int 21h
   124 00000161 FEC0                <1>     inc al  ;Turn it into a 1 based number
   125                              <1> .notCurDrv:
   126 00000163 88C2                <1>     mov dl, al  ;Save the 1-based drive letter in dl
   127 00000165 0440                <1>     add al, "@" ;Convert into a drive letter
   128 00000167 B43A                <1>     mov ah, ":"
   129 00000169 66AB                <1>     stosw   ;Store the drive letter in the buffer, adv rdi by 2
   130 0000016B AC                  <1>     lodsb   ;Get the first char from the pathspec given...
   131 0000016C 48FFCE              <1>     dec rsi ;...and go back to this char
   132 0000016F 3A05(00000000)      <1>     cmp al, byte [pathSep]  ;If this is a pathsep, we have abs path!
   133 00000175 7431                <1>     je .cpLp    ;Avoid getting the current directory and copy immediately!
   134 00000177 8A05(00000000)      <1>     mov al, byte [pathSep]  ;Get a pathsep
   135 0000017D AA                  <1>     stosb       ;and store it, incrementing rdi
   136 0000017E 56                  <1>     push rsi    ;Save the source of chars in the spec now
   137 0000017F 4889FE              <1>     mov rsi, rdi
   138 00000182 B800470000          <1>     mov eax, 4700h  ;Get current dir for drive in here
   139 00000187 CD21                <1>     int 21h
   140 00000189 5E                  <1>     pop rsi     ;Get back the source of chars 
   141 0000018A 0F82AF030000        <1>     jc badDrvExit
   142 00000190 B812120000          <1>     mov eax, 1212h  ;Strlen from char past leading sep, get the length in ecx 
   143 00000195 CD2F                <1>     int 2fh
   144 00000197 FFC9                <1>     dec ecx         ;Drop the terminating null from the count
   145 00000199 4801CF              <1>     add rdi, rcx    ;Go to the terminating null
   146 0000019C 8A05(00000000)      <1>     mov al, byte [pathSep]
   147 000001A2 3847FF              <1>     cmp byte [rdi - 1], al  ;If the char behind is a pathsep, skip doubling!
   148 000001A5 7401                <1>     je .cpLp
   149 000001A7 AA                  <1>     stosb           ;Store the pathsep over this null, inc rdi
   150                              <1> .cpLp:
   151 000001A8 A4                  <1>     movsb   ;Now copy one char at a time
   152 000001A9 483B35(46010000)    <1>     cmp rsi, qword [tmpNamePtr2]    ;Check if we are equal to end of string ptr
   153 000001B0 75F6                <1>     jne short .cpLp
   154 000001B2 31C0                <1>     xor eax, eax
   155 000001B4 AA                  <1>     stosb   ;Store the null terminating char
   156                              <1> ;Now we normalise the pathspec
   157 000001B5 488D35(3E000000)    <1>     lea rsi, pathspec
   158 000001BC 4889F7              <1>     mov rdi, rsi
   159 000001BF B811120000          <1>     mov eax, 1211h  ;Normalise the pathspec provided
   160 000001C4 CD2F                <1>     int 2fh 
   161                              <1> ;Now we produce a backup/working filespec
   162 000001C6 488D35(3E000000)    <1>     lea rsi, pathspec
   163 000001CD 488D3D(BE000000)    <1>     lea rdi, wkfile ;This pathspec always has an extension
   164 000001D4 E8BA060000          <1>     call strcpy
   165                              <1> ;rbp still has the cmdArgs ptr. Use it here for the fcb!!
   166 000001D9 488D7D00            <1>     lea rdi, qword [rbp + cmdArgs.fcb1]
   167 000001DD B801290000          <1>     mov eax, 2901h
   168 000001E2 CD21                <1>     int 21h
   169 000001E4 3CFF                <1>     cmp al, -1  ;If this is the case, the drive specified is bad!
   170 000001E6 0F8453030000        <1>     je badDrvExit
   171                              <1> ;Now invalidate tmpNamePtr and tmpNamePtr2
   172 000001EC 31C9                <1>     xor ecx, ecx
   173 000001EE 48890D(3E010000)    <1>     mov qword [tmpNamePtr], rcx
   174 000001F5 48890D(46010000)    <1>     mov qword [tmpNamePtr2], rcx
   175 000001FC FFC9                <1>     dec ecx
   176 000001FE 488D3D(BE000000)    <1>     lea rdi, wkfile
   177 00000205 4889FB              <1>     mov rbx, rdi    ;Save address of head of file name
   178 00000208 31C0                <1>     xor eax, eax
   179 0000020A F2AE                <1>     repne scasb     ;rdi points past terminating null
   180 0000020C 4889FE              <1>     mov rsi, rdi
   181 0000020F FD                  <1>     std             ;Go in reverse now
   182                              <1> .fileNameSearch:
   183 00000210 AC                  <1>     lodsb
   184 00000211 3A05(00000000)      <1>     cmp al, byte [pathSep]  ;Are we at a pathsep?
   185 00000217 740C                <1>     je .fileNameOk  ;Yes, stop scanning
   186 00000219 4839DE              <1>     cmp rsi, rbx    ;Are we at the head of the path?
   187 0000021C 75F2                <1>     jne .fileNameSearch ;If not, keep going back
   188 0000021E 4881EE02000000      <1>     sub rsi, 2  ;Pretend we are past a pathSep
   189                              <1> .fileNameOk:
   190 00000225 4881C602000000      <1>     add rsi, 2  ;Now point to the first char of the buffer!
   191 0000022C 488935(3E010000)    <1>     mov qword [fileNamePtr], rsi    ;Save the ptr
   192 00000233 FC                  <1>     cld         ;Now go forwards!
   193 00000234 B908000000          <1>     mov ecx, 8  ;number of chars to search thru
   194                              <1> .extSearch:
   195 00000239 AC                  <1>     lodsb
   196 0000023A 84C0                <1>     test al, al
   197 0000023C 740B                <1>     jz .insertExt
   198 0000023E 3C2E                <1>     cmp al, "."
   199 00000240 7411                <1>     je .extFound
   200 00000242 FFC9                <1>     dec ecx
   201 00000244 75F3                <1>     jnz .extSearch    
   202 00000246 48FFC6              <1>     inc rsi ;Go to the next position so the below works
   203                              <1> .insertExt:
   204                              <1>     ;rsi points just past the null
   205 00000249 C646FF2E            <1>     mov byte [rsi - 1], "." ;Store a pathsep
   206 0000024D C70620202000        <1>     mov dword [rsi], "   "   ;Store empty extension so no accidental BAK issues.
   207                              <1> .extFound:
   208 00000253 488935(46010000)    <1>     mov qword [fileExtPtr], rsi
   209                              <1> ;Now we have all the metadata for the filename we are working with
   210 0000025A 8B06                <1>     mov eax, dword [rsi]
   211 0000025C 3D42414B00          <1>     cmp eax, "BAK"  ;Is this a bakup file?
   212 00000261 488D15(BE010000)    <1>     lea rdx, badFileExt
   213 00000268 0F84E1020000        <1>     je badExitMsg   ;If yes, error!
   214 0000026E C70624242400        <1>     mov dword [rsi], "$$$"   ;Now we store working file $$$ extension 
   215                              <1> ;Now we check to make sure the path has no global filename chars
   216                              <1> wildcardCheck:
   217 00000274 488D35(3E000000)    <1>     lea rsi, pathspec
   218                              <1> .mainlp:
   219 0000027B AC                  <1>     lodsb
   220 0000027C 84C0                <1>     test al, al ;Once we're at the null char, proceed
   221 0000027E 740C                <1>     jz fileOpen
   222 00000280 3C3F                <1>     cmp al, "?"
   223 00000282 0F84B7020000        <1>     je badDrvExit
   224 00000288 3C2A                <1>     cmp al, "*"
   225 0000028A 75EF                <1>     jne .mainlp
   226                              <1> ;Now we open the file to check if it exists and if it does, if it is readonly
   227                              <1> fileOpen:
   228                              <1> ;first set the handles to -1
   229 0000028C C705(3A000000)FFFF- <1>     mov dword [readHdl], -1 ;Init the handles to -1
   229 00000294 FFFF                <1>
   230                              <1> ;Now we search for the file
   231 00000296 488D15(3E000000)    <1>     lea rdx, pathspec
   232 0000029D B906000000          <1>     mov ecx, dirIncFiles
   233 000002A2 B8004E0000          <1>     mov eax, 4E00h  ;Find First 
   234 000002A7 CD21                <1>     int 21h
   235 000002A9 7243                <1>     jc .fileNotFound
   236                              <1> ;Check if file is read only
   237 000002AB B8002F0000          <1>     mov eax, 2F00h  ;Get a pointer to the DTA in rbx
   238 000002B0 CD21                <1>     int 21h
   239 000002B2 0FB64315            <1>     movzx eax, byte [rbx + ffBlock.attribFnd]
   240 000002B6 A840                <1>     test al, dirCharDev
   241 000002B8 0F8519140000        <1>     jnz charDevFail
   242 000002BE A801                <1>     test al, dirReadOnly
   243 000002C0 7407                <1>     jz short .notReadOnly
   244                              <1> .readOnly:
   245                              <1> ;Read only files here
   246 000002C2 C605(02000000)FF    <1>     mov byte [roFlag], -1   ;Set read only flag!
   247                              <1> .notReadOnly:
   248                              <1> ;File exists, lets open it, to read from
   249 000002C9 B8203D0000          <1>     mov eax, (3Dh << 8) | ReadAccess | denyWriteShare
   250 000002CE 488D15(3E000000)    <1>     lea rdx, pathspec    ;Get the pointer to the working filename
   251 000002D5 CD21                <1>     int 21h         ;Open the file
   252 000002D7 730C                <1>     jnc short .backupOpened
   253                              <1> ;File failed to open
   254 000002D9 488D15(DB000000)    <1>     lea rdx, badOpenStr
   255 000002E0 E96A020000          <1>     jmp badExitMsg
   256                              <1> .backupOpened:
   257                              <1> ;Backup opened and handle in ax.
   258 000002E5 668905(3A000000)    <1>     mov word [readHdl], ax  ;Store the read handle here
   259 000002EC EB1F                <1>     jmp short createWorkingFile
   260                              <1> .fileNotFound:
   261                              <1> ;Maybe new file? Check reason for error! If FNF, its good!
   262 000002EE 663D0200            <1>     cmp ax, errFnf  ;If its a file not found error, then we are good!
   263 000002F2 488D15(DB000000)    <1>     lea rdx, badOpenStr ;We can't open the file for whatever reason
   264 000002F9 0F8550020000        <1>     jne badExitMsg
   265                              <1> ;Error was file not found so we can make the file!
   266 000002FF C605(03000000)FF    <1>     mov byte [newFileFlag], -1  ;Set the new file flag!
   267 00000306 C605(05000000)FF    <1>     mov byte [eofReached], -1   ;Setup that we at eof
   268                              <1> createWorkingFile:
   269                              <1> ;Now open a new file with triple question mark extension
   270                              <1> ;rdi -> Path to file with $$$ (the working file)
   271 0000030D 488D15(BE000000)    <1>     lea rdx, wkfile    ;Get a pointer to this filename
   272 00000314 B8005B0000          <1>     mov eax, 5B00h  ;Create file (atomic), prevent two edlins from editing same file
   273 00000319 31C9                <1>     xor ecx, ecx    ;Clear all file attributes (normal file)
   274 0000031B CD21                <1>     int 21h
   275 0000031D 488D15(BC000000)    <1>     lea rdx, badCreatStr    ;Creating the working file will fail if already exits
   276 00000324 0F8225020000        <1>     jc badExitMsg   ;This prevents someone from overriding the file
   277 0000032A 668905(3C000000)    <1>     mov word [writeHdl], ax ;Store a pointer to the write handle
   278 00000331 F605(03000000)FF    <1>     test byte [newFileFlag], -1 ;If set, this is a new file!
   279 00000338 740E                <1>     jz short .notNewFile
   280 0000033A 488D15(3C000000)    <1>     lea rdx, newStr
   281 00000341 B800090000          <1>     mov eax, 0900h
   282 00000346 CD21                <1>     int 21h
   283                              <1> .notNewFile:
   284                              <1> ;Now the following:
   285                              <1> ;1) Allocate max memory (1Mb max)
   286                              <1> ;2) If new file, goto 4. Print "new file" message
   287                              <1> ;3) Else, fill up to 75% of arena according to table. If 
   288                              <1> ;    EOF reached (either due to no bytes left or ^Z (if enabled))
   289                              <1> ;    print "EOF reached message".
   290                              <1> ;4) Install Int 23h handler
   291                              <1> ;5) Goto main loop
   292                              <1> allocateMemory:
   293 00000348 31DB                <1>     xor ebx, ebx
   294 0000034A BB00000100          <1>     mov ebx, 10000h ;Start trying to allocate at 1Mb
   295 0000034F B800480000          <1>     mov eax, 4800h
   296 00000354 CD21                <1>     int 21h
   297 00000356 731E                <1>     jnc short .loadProgram
   298                              <1>     ;If the allocation failed, eax has max paragraphs
   299 00000358 3D10000000          <1>     cmp eax, 10h    ;If we have less than 256 bytes available, fail
   300 0000035D 720B                <1>     jb short .notEnoughMem
   301 0000035F 89C3                <1>     mov ebx, eax    ;Get the number of paragraphs into ebx for request
   302 00000361 B800480000          <1>     mov eax, 4800h
   303 00000366 CD21                <1>     int 21h
   304 00000368 730C                <1>     jnc short .loadProgram
   305                              <1> .notEnoughMem:
   306 0000036A 488D15(7B010000)    <1>     lea rdx, badMemFull
   307 00000371 E9D9010000          <1>     jmp badExitMsg
   308                              <1> .loadProgram:
   309                              <1> ;rax has pointer here
   310 00000376 488905(0E000000)    <1>     mov qword [memPtr], rax
   311 0000037D 4889C6              <1>     mov rsi, rax
   312 00000380 C1E304              <1>     shl ebx, 4  ;Multiply by 16 to get number of bytes
   313 00000383 4801DE              <1>     add rsi, rbx
   314 00000386 48FFCE              <1>     dec rsi     ;Point rsi to the last char of the arena
   315 00000389 488935(30000000)    <1>     mov qword [endOfArena], rsi
   316 00000390 891D(06000000)      <1>     mov dword [arenaSize], ebx  ;Save number of bytes in arena here
   317 00000396 F605(03000000)FF    <1>     test byte [newFileFlag], -1 ;We skip setting the 1/4 and 3/4 markers 
   318 0000039D 7522                <1>     jnz .newFile
   319 0000039F 4889C6              <1>     mov rsi, rax    ;Save the pointer to memory arena in rsi
   320 000003A2 31C9                <1>     xor ecx, ecx    ;Zero the upper 32 bits
   321 000003A4 678D0C5B            <1>     lea ecx, dword [2*ebx + ebx]    ;Multiply ebx by 3 into ecx
   322 000003A8 C1E902              <1>     shr ecx, 2  ;Divide by 4 to get # of bytes to default fill by
   323 000003AB 890D(16000000)      <1>     mov dword [fillPtr], ecx   ;Save number of bytes to fill arena with
   324 000003B1 480105(16000000)    <1>     add qword [fillPtr], rax   ;Turn into offset from start of arena
   325 000003B8 C1EB02              <1>     shr ebx, 2  ;Divide by 4 to get # of bytes to default free until
   326 000003BB 891D(0A000000)      <1>     mov dword [freeCnt], ebx   ;Save number of bytes to free from the arena
   327                              <1> .newFile:
   328                              <1> ;Now we setup the edit and command buffers
   329 000003C1 C605(65020000)FD    <1>     mov byte [workLine + line.bBufLen], lineLen
   330 000003C8 C605(4E010000)80    <1>     mov byte [cmdLine + line.bBufLen], halflineLen
   331 000003CF 66C705(1E000000)01- <1>     mov word [curLineNum], 1    ;Start at line 1
   331 000003D7 00                  <1>
   332 000003D8 488905(20000000)    <1>     mov qword [curLinePtr], rax
   333 000003DF C6001A              <1>     mov byte [rax], EOF ;Store an EOF at the start of the buffer!
   334 000003E2 488905(28000000)    <1>     mov qword [eofPtr], rax
   335                              <1> ;Nice trick, ensure we dont print any errors on append when initially loading the
   336                              <1> ; file! Since we are appending, we setup as if the user typed in an arg. 
   337                              <1> ;arg1 is already zero due to BSS zeroing
   338 000003E9 C605(D8010000)01    <1>     mov byte [argCnt], 1    ;Default to one argument! arg1 = 0 means load to 3/4!
   339 000003F0 F605(03000000)FF    <1>     test byte [newFileFlag], -1
   340 000003F7 7513                <1>     jnz getCommand
   341 000003F9 C605(64020000)FF    <1>     mov byte [noAppendErr], -1
   342 00000400 E8100E0000          <1>     call appendLines
   343 00000405 C605(64020000)00    <1>     mov byte [noAppendErr], 0
   344                              <1> getCommand:
   345 0000040C 488D25(40060000)    <1>     lea rsp, stackTop   ;Reset the stack pointer
   346 00000413 488D1513060000      <1>     lea rdx, i23h
   347 0000041A B823250000          <1>     mov eax, 2523h  ;Set Interrupt handler for Int 23h
   348 0000041F CD21                <1>     int 21h
   349 00000421 B82A000000          <1>     mov eax, prompt
   350 00000426 E852110000          <1>     call printChar
   351 0000042B 488D15(4E010000)    <1>     lea rdx, cmdLine
   352 00000432 B8000A0000          <1>     mov eax, 0A00h  ;Take buffered input.
   353 00000437 CD21                <1>     int 21h
   354 00000439 E83D110000          <1>     call printLF 
   355 0000043E 488D35(50010000)    <1>     lea rsi, qword [cmdLine + halfLine.pString] ;Point to the text of the line
   356 00000445 488935(D0010000)    <1>     mov qword [charPtr], rsi
   357                              <1> ;Now we parse the command line!
   358                              <1> ;NOTE: Multiple commands may be on the same command line.
   359                              <1> ;Commands are terminated by a command letter (except in the
   360                              <1> ; case of S and R where they may be followed by a string).
   361                              <1> ;If we encounter a CR in the string parsing, then we are
   362                              <1> ; finished with this command line. Else, we keep parsing the
   363                              <1> ; same command line, until all the chars in the buffer 
   364                              <1> ; have been processed and/or a CR has been hit.
   365                              <1> parseCommand:
   366 0000044C 31C0                <1>     xor eax, eax
   367 0000044E 8805(D8010000)      <1>     mov byte [argCnt], al
   368 00000454 488905(D9010000)    <1>     mov qword [argTbl], rax ;Clear the argument table
   369 0000045B 8805(E1010000)      <1>     mov byte [qmarkSet], al
   370 00000461 488B35(D0010000)    <1>     mov rsi, qword [charPtr]    ;Get rsi to the right place in command line
   371 00000468 488D2D(D9010000)    <1>     lea rbp, argTbl
   372                              <1> .parse:
   373 0000046F FE05(D8010000)      <1>     inc byte [argCnt]   ;Parsing an argument
   374 00000475 E8E0040000          <1>     call parseEntry ;Returns in bx the word to store in the arg table
   375 0000047A 0FB63D(D8010000)    <1>     movzx edi, byte [argCnt]
   376 00000481 FFCF                <1>     dec edi ;Turn into offset
   377 00000483 66895C7D00          <1>     mov word [rbp + 2*rdi], bx  ;Store the argument
   378 00000488 48FFCE              <1>     dec rsi     ;Go back to the first char past the argument
   379 0000048B E86E050000          <1>     call skipSpaces ;Skip spaces
   380 00000490 3C2C                <1>     cmp al, "," ;Is the first char the argument separator?
   381 00000492 74DB                <1>     je .parse
   382 00000494 48FFCE              <1>     dec rsi ;Move rsi back to the non comma char
   383 00000497 E862050000          <1>     call skipSpaces
   384 0000049C 3C3F                <1>     cmp al, "?"
   385 0000049E 750C                <1>     jne short .notQmark
   386 000004A0 C605(E1010000)FF    <1>     mov byte [qmarkSet], -1
   387 000004A7 E852050000          <1>     call skipSpaces ;Get the next char (must be a cmd char) in al
   388                              <1> .notQmark:
   389 000004AC 3C61                <1>     cmp al, "a"
   390 000004AE 7202                <1>     jb short .noUC
   391 000004B0 24DF                <1>     and al, 0DFh    ;Convert cmd char to upper case if LC 
   392                              <1> .noUC:
   393 000004B2 488D3D(00000000)    <1>     lea rdi, cmdLetterTable
   394 000004B9 B90F000000          <1>     mov ecx, cmdLetterTableL
   395 000004BE F2AE                <1>     repne scasb
   396 000004C0 0F85DA110000        <1>     jne printComErr ;Print an error if char not in table
   397 000004C6 F7D1                <1>     not ecx ;1's compliment to subtract 1 too
   398 000004C8 81C10F000000        <1>     add ecx, cmdLetterTableL    ;Get L->R offset into table
   399                              <1> ;Now check the R/O permissions for the selected function
   400                              <1> ;ecx has the offset into the table
   401 000004CE F605(02000000)FF    <1>     test byte [roFlag], -1  ;If this flag is not set, ignore r/o
   402 000004D5 7421                <1>     jz short execCmd
   403 000004D7 488D2D(2D000000)    <1>     lea rbp, cmdRoTable
   404 000004DE F6440D00FF          <1>     test byte [rbp + rcx], -1   ;Test the flag
   405 000004E3 7513                <1>     jnz short execCmd
   406 000004E5 488D15(E3010000)    <1>     lea rdx, badROcmd
   407 000004EC B800090000          <1>     mov eax, 0900h
   408 000004F1 CD21                <1>     int 21h
   409 000004F3 E9A8110000          <1>     jmp printComErr
   410                              <1> execCmd:
   411 000004F8 488935(D0010000)    <1>     mov qword [charPtr], rsi
   412 000004FF 488D2D(0F000000)    <1>     lea rbp, cmdFcnTable
   413 00000506 480FBF5C4D00        <1>     movsx rbx, word [rbp + 2*rcx]    ;Get word ptr into rbx
   414 0000050C 4801EB              <1>     add rbx, rbp    ;Convert the word offset from cmdFcnTbl to pointer
   415 0000050F FFD3                <1>     call rbx
   416                              <1> nextCmd:
   417 00000511 488B35(D0010000)    <1>     mov rsi, qword [charPtr]
   418 00000518 E8E1040000          <1>     call skipSpaces ;Now move to the "following command" or CR
   419 0000051D 3C0D                <1>     cmp al, CR
   420 0000051F 0F84E7FEFFFF        <1>     je getCommand   ;If CR, end of line. Get new command
   421 00000525 3C1A                <1>     cmp al, EOF
   422 00000527 7404                <1>     je short .eocChar
   423 00000529 3C3B                <1>     cmp al, ";"
   424 0000052B 7503                <1>     jne short .skipEocChar
   425                              <1> .eocChar:
   426 0000052D 48FFC6              <1>     inc rsi ;Move rsi ahead one to avoid the below...
   427                              <1> .skipEocChar:
   428 00000530 48FFCE              <1>     dec rsi ;Move rsi back to the first char of the new command
   429 00000533 488935(D0010000)    <1>     mov qword [charPtr], rsi    ;Save the command line pointer
   430 0000053A E90DFFFFFF          <1>     jmp parseCommand
   431                              <1> 
   432                              <1> ;----Bad Exits----
   433                              <1> badDrvExit:
   434 0000053F 488D15(71000000)    <1>     lea rdx, badDrvStr
   435 00000546 EB07                <1>     jmp short badExitMsg
   436                              <1> badParmExit:
   437 00000548 488D15(44010000)    <1>     lea rdx, badParm    ;Bad number of parameters
   438                              <1> badExitMsg:
   439 0000054F 4885D2              <1>     test rdx, rdx   ;Check if null ptr => Dont print on exit
   440 00000552 7407                <1>     jz short badExit
   441 00000554 B800090000          <1>     mov eax, 0900h
   442 00000559 CD21                <1>     int 21h
   443                              <1> badExit:
   444 0000055B B8FF4C0000          <1>     mov eax, 4CFFh
   445 00000560 CD21                <1>     int 21h
    35                                  %include "./Source/edutils.asm"
     1                              <1> ;General Utility functions for edlin go here
     2                              <1> 
     3                              <1> okPrompt:
     4                              <1> ;Checks if the user typed ? on a search or replace and prompts y/n
     5                              <1> ; indicating the response to the caller!
     6                              <1> ;Returns: ZF=ZE if Y returned, ZF=NZ if N returned
     7 00000562 F605(E1010000)FF    <1>     test byte [qmarkSet], -1
     8                              <1>     retz
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26                              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29 00000569 7501                <3>  j%-1 short %%a
    30                              <3>  return
    13                              <4> %%_ret:
    14 0000056B C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
     9                              <1> .lp:
    10 0000056C 488D15(5A020000)    <1>     lea rdx, okString
    11 00000573 E8F00F0000          <1>     call printString
    12 00000578 B8010C0000          <1>     mov eax, 0C01h  ;Take input one byte, return input byte in al
    13 0000057D CD21                <1>     int 21h
    14 0000057F 50                  <1>     push rax        ;Save the char as we print CRLF to denote acceptance
    15 00000580 E8EF0F0000          <1>     call printCRLF
    16 00000585 58                  <1>     pop rax
    17 00000586 50                  <1>     push rax
    18 00000587 B813120000          <1>     mov eax, 1213h  ;Get DOS to Uppercase for us
    19 0000058C CD2F                <1>     int 2fh
    20 0000058E 5A                  <1>     pop rdx         ;Pop the original char back
    21 0000058F 3C59                <1>     cmp al, "Y"
    22                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000591 74(6B)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    23 00000593 3C4E                <1>     cmp al, "N"
    24 00000595 75D5                <1>     jne .lp         ;If not Y or N, go again.
    25 00000597 FEC0                <1>     inc al          ;Clear ZF, guaranteed to clear ZF since al = N
    26                              <1>     return
    13                              <2> %%_ret:
    14 00000599 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    27                              <1> 
    28                              <1> 
    29                              <1> findFirst:
    30 0000059A 488D3D(2E050000)    <1>     lea rdi, fndString1 + 1 ;Point to start of the actual string space!
    31 000005A1 C605(12050000)FF    <1>     mov byte [keepOld], -1  ;We want to keep the old search data!
    32 000005A8 E84D010000          <1>     call getFindPatrn
    33 000005AD 85C9                <1>     test ecx, ecx   ;Was the length of the copy 0?
    34                              <1>     retz            ;Return if so!
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000005AF 74(99)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    35 000005B1 3C1A                <1>     cmp al, EOF
    36 000005B3 7507                <1>     jne .replaceOld
    37 000005B5 C605(12050000)00    <1>     mov byte [keepOld], 0   ;Reset the old data if EOF!
    38                              <1> .replaceOld: 
    39 000005BC 66890D(13050000)    <1>     mov word [fndLenOld], cx  ;Save the length!
    40 000005C3 31C9                <1>     xor ecx, ecx
    41 000005C5 3C0D                <1>     cmp al, CR
    42 000005C7 7409                <1>     je .makeSrchBuf
    43 000005C9 803D(11050000)00    <1>     cmp byte [findMod], 0
    44 000005D0 7403                <1>     jz .repBuf
    45                              <1> .makeSrchBuf:
    46 000005D2 48FFCE              <1>     dec rsi
    47                              <1> .repBuf:
    48 000005D5 488935(D0010000)    <1>     mov qword [charPtr], rsi
    49 000005DC 488D3D(AF050000)    <1>     lea rdi, fndString2 + 1     ;Now we copy to the second buffer!
    50 000005E3 E812010000          <1>     call getFindPatrn
    51 000005E8 803D(11050000)00    <1>     cmp byte [findMod], 0   ;Are we replace?
    52 000005EF 750E                <1>     jnz .notRep
    53                              <1> ;Here only if we are replacing the string!
    54 000005F1 3C0D                <1>     cmp al, CR  ;Did we read the last char in the string?
    55 000005F3 7503                <1>     jne .eos
    56 000005F5 48FFCE              <1>     dec rsi     ;Go to the last char itself
    57                              <1> .eos:
    58 000005F8 488935(D0010000)    <1>     mov qword [charPtr], rsi
    59                              <1> .notRep:
    60 000005FF 66890D(15050000)    <1>     mov word [fndLenNew], cx     ;Save the new length of the copied string
    61 00000606 0FB71D(D9010000)    <1>     movzx ebx, word [arg1]
    62 0000060D 85DB                <1>     test ebx, ebx   
    63 0000060F 751E                <1>     jnz .havLine
    64 00000611 803D(10050000)00    <1>     cmp byte [srchMode], 0  ;If clear, we search from current line + 1!
    65 00000618 7507                <1>     jne .curLin
    66 0000061A BB01000000          <1>     mov ebx, 1
    67 0000061F EB09                <1>     jmp short .chkLineOk
    68                              <1> .curLin:
    69 00000621 0FB71D(1E000000)    <1>     movzx ebx, word [curLineNum]
    70 00000628 FFC3                <1>     inc ebx
    71                              <1> .chkLineOk:
    72 0000062A E8D2010000          <1>     call checkArgOrder
    73                              <1> .havLine:
    74 0000062F E81C020000          <1>     call findLine   ;Setup the vars to start searching!
    75 00000634 48893D(17050000)    <1>     mov qword [fndStrPtr], rdi
    76 0000063B 48893D(1F050000)    <1>     mov qword [fndLinePtr], rdi
    77 00000642 668915(27050000)    <1>     mov word [fndLineNum], dx
    78 00000649 0FB71D(DB010000)    <1>     movzx ebx, word [arg2]  ;Get the end of search range
    79 00000650 6681FBFFFF          <1>     cmp bx, -1
    80 00000655 6681DBFFFF          <1>     sbb bx, -1
    81 0000065A E8F1010000          <1>     call findLine   ;Get the vars for the end of the search
    82 0000065F 4889F9              <1>     mov rcx, rdi
    83 00000662 482B0D(17050000)    <1>     sub rcx, qword [fndStrPtr]  ;Get the number of chars we will be scanning
    84 00000669 0CFF                <1>     or al, -1   ;Clear ZF
    85 0000066B 67E309              <1>     jecxz .exit
    86 0000066E 663B0D(13050000)    <1>     cmp cx, word [fndLenOld]  ;Is the init string 
    87 00000675 7301                <1>     jae .findNext
    88                              <1> .exit:
    89                              <1>     return
    13                              <2> %%_ret:
    14 00000677 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    90                              <1> .findNext:
    91 00000678 890D(29050000)      <1>     mov dword [fndSrchLen], ecx
    92                              <1> findNext:
    93                              <1> ;Finds our next match for the string in fndString1
    94                              <1> ;Input:
    95                              <1> ;   byte [fndString1 + 1] = String we are searching for
    96                              <1> ;   word [fndLenOld] = Length of the string we are searching for
    97                              <1> ;   qword [fndStrPtr] = Ptr to the start of where to start scanning from
    98                              <1> ;   word [fndLineNum] = Line number of the string we are searching from
    99                              <1> ;   dword [fndSrchLen] = Length of the arena we are searching.
   100                              <1> ;   qword [fndLinePtr] = Ptr to the start of the line we are on.
   101                              <1> ;Output:
   102                              <1> ;   ZF=ZE if we found the search string. Else ZF=NZ.
   103                              <1> ;   qword [fndStrPtr], word [fndLineNum], dword [fndSrchLen] updated.
   104                              <1> ;   qword [fndLinePtr] points to start of line we found match
   105                              <1> 
   106 0000067E 8A05(2E050000)      <1>     mov al, byte [fndString1 + 1]
   107 00000684 8B0D(29050000)      <1>     mov ecx, dword [fndSrchLen]
   108 0000068A 488B3D(17050000)    <1> 	mov rdi, qword [fndStrPtr]
   109                              <1> .lp:
   110 00000691 4885FF              <1>     test rdi, rdi           ;Clear ZF in case ecx is 0
   111 00000694 67E3E0              <1>     jecxz findFirst.exit    ;Just exit in that case
   112 00000697 F2AE                <1>     repne scasb
   113                              <1>     retnz
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000699 75(77)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   114 0000069B 89CA                <1>     mov edx, ecx    ;Save the remaining chars to scan thru
   115 0000069D 4889FB              <1>     mov rbx, rdi    ;Save the ptr to the end of the string we scanned
   116 000006A0 0FB70D(13050000)    <1>     movzx ecx, word [fndLenOld] ;Get the match string length
   117 000006A7 FFC9                <1>     dec ecx
   118 000006A9 488D35(2F050000)    <1>     lea rsi, fndString1 + 2
   119 000006B0 38C0                <1>     cmp al, al  ;Set the zero flag incase ECX = 0
   120 000006B2 F3A6                <1>     repe cmpsb  ;Compare the remainder of the strings
   121 000006B4 89D1                <1>     mov ecx, edx    ;Return the remaining chars for search
   122 000006B6 4889DF              <1>     mov rdi, rbx    ;Retur the ptr
   123 000006B9 75D6                <1>     jne .lp ;Keep searching if the two strings were not 100% the same
   124 000006BB 890D(29050000)      <1>     mov dword [fndSrchLen], ecx
   125 000006C1 4889F9              <1>     mov rcx, rdi
   126 000006C4 48893D(17050000)    <1>     mov qword [fndStrPtr], rdi
   127 000006CB 488B3D(1F050000)    <1>     mov rdi, qword [fndLinePtr]
   128 000006D2 4829F9              <1>     sub rcx, rdi
   129 000006D5 B00A                <1>     mov al, LF
   130 000006D7 0FB715(27050000)    <1>     movzx edx, word [fndLineNum]
   131                              <1> ;Now figure out which line we matched on
   132                              <1> .getLp:
   133 000006DE FFC2                <1>     inc edx
   134 000006E0 4889FB              <1>     mov rbx, rdi
   135 000006E3 F2AE                <1>     repne scasb
   136 000006E5 74F7                <1>     jz .getLp 
   137 000006E7 FFCA                <1>     dec edx
   138 000006E9 668915(27050000)    <1>     mov word [fndLineNum], dx
   139 000006F0 48891D(1F050000)    <1>     mov qword [fndLinePtr], rbx
   140 000006F7 31C0                <1>     xor eax, eax    ;Clear the ZF
   141                              <1>     return
    13                              <2> %%_ret:
    14 000006F9 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   142                              <1> 
   143                              <1> getFindPatrn:
   144                              <1> ;Moves the find pattern until ^Z or <CR> found. 
   145                              <1> ;Input: rsi -> Command buffer
   146                              <1> ;       rdi -> Storage buffer
   147                              <1> ; byte [keepOld] = If we copy 0 chars, do we use old search data or not?
   148                              <1> ;Output:
   149                              <1> ;       al = Terminating char
   150                              <1> ;       ecx = Number of chars copied
   151                              <1> ;       rsi -> Char past the terminating char
   152                              <1> ;       rdi -> Same in storage buffer
   153 000006FA 31C9                <1>     xor ecx, ecx
   154                              <1> .lp:
   155 000006FC AC                  <1>     lodsb           ;Get char from buffer
   156 000006FD 3C16                <1>     cmp al, CMD     ;If not a ^V, check if it is a terminating char
   157 000006FF 7508                <1>     jne .noConvert
   158 00000701 AC                  <1>     lodsb   ;Get the next char to convert into a control character
   159 00000702 E8EF000000          <1>     call doControl  ;Convert it!
   160 00000707 EB04                <1>     jmp short .checkCR  ;Ignore <EOF> in this case
   161                              <1> .noConvert:
   162 00000709 3C1A                <1>     cmp al, EOF ;Was char an <EOF>?
   163 0000070B 7409                <1>     je .end     ;End if so!
   164                              <1> .checkCR:
   165 0000070D 3C0D                <1>     cmp al, CR  ;Was char a <CR>?
   166 0000070F 7405                <1>     je .end     ;End if so!
   167 00000711 AA                  <1>     stosb       ;Else store and
   168 00000712 FFC1                <1>     inc ecx     ;inc the copy counter!
   169 00000714 EBE6                <1>     jmp short .lp
   170                              <1> .end:
   171 00000716 85C9                <1>     test ecx, ecx   ;Did we copy zero chars?
   172 00000718 7409                <1>     jz .noNew       ;If so, check if we should use previous data...
   173 0000071A 57                  <1>     push rdi
   174 0000071B 4829CF              <1>     sub rdi, rcx    ;Else get a ptr to the start of the buffer
   175 0000071E 884FFF              <1>     mov byte [rdi - 1], cl  ;And place the string length w/o terminator!
   176 00000721 5F                  <1>     pop rdi
   177                              <1>     return
    13                              <2> %%_ret:
    14 00000722 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   178                              <1> .noNew:
   179 00000723 F605(12050000)FF    <1>     test byte [keepOld], -1   ;Do we want to use old data?
   180 0000072A 7504                <1>     jne .useOld     ;Jump if so!
   181 0000072C 884FFF              <1>     mov byte [rdi - 1], cl  ;Else, reset the buffer length!! No search data!
   182                              <1>     return
    13                              <2> %%_ret:
    14 0000072F C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   183                              <1> .useOld:
   184 00000730 0FB64FFF            <1>     movzx ecx, byte [rdi - 1]   ;So get the length of the buffer
   185 00000734 4801CF              <1>     add rdi, rcx                ;And go to the end of the string!
   186                              <1>     return
    13                              <2> %%_ret:
    14 00000737 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   187                              <1> 
   188                              <1> replaceLine:
   189                              <1> ;Replaces a line in memory with a line in a buffer.
   190                              <1> ;Input: ecx = New line length
   191                              <1> ;       rsi -> New line source ptr
   192                              <1> ;       edx = Old line length
   193                              <1> ;       rdi -> Old line ptr
   194 00000738 39D1                <1>     cmp ecx, edx
   195 0000073A 7447                <1>     je .doCopy
   196 0000073C 51                  <1>     push rcx
   197 0000073D 56                  <1>     push rsi
   198 0000073E 57                  <1>     push rdi
   199 0000073F 4889FE              <1>     mov rsi, rdi
   200 00000742 4801D6              <1>     add rsi, rdx    ;Go to the end of the old line 
   201 00000745 4801CF              <1>     add rdi, rcx    ;Go to where the new line will end
   202 00000748 488B05(28000000)    <1>     mov rax, qword [eofPtr]
   203 0000074F 4829D0              <1>     sub rax, rdx    ;See if we have enough space for the new line!!
   204 00000752 4801C8              <1>     add rax, rcx
   205 00000755 483B05(30000000)    <1>     cmp rax, qword [endOfArena]
   206 0000075C 0F83350F0000        <1>     jae printMemErr
   207 00000762 488705(28000000)    <1>     xchg qword [eofPtr], rax    ;This will be the new eof
   208 00000769 4889C1              <1>     mov rcx, rax    ;Get the old eofPtr in rcx
   209 0000076C 4829F1              <1>     sub rcx, rsi
   210 0000076F 4839FE              <1>     cmp rsi, rdi
   211 00000772 7707                <1>     ja .noRevMove
   212 00000774 4801CE              <1>     add rsi, rcx    ;Here we setup reverse copy!!
   213 00000777 4801CF              <1>     add rdi, rcx
   214 0000077A FD                  <1>     std
   215                              <1> .noRevMove:
   216 0000077B FFC1                <1>     inc ecx         ;Add a char for the EOF itself!
   217 0000077D F3A4                <1>     rep movsb
   218 0000077F FC                  <1>     cld
   219 00000780 5F                  <1>     pop rdi
   220 00000781 5E                  <1>     pop rsi
   221 00000782 59                  <1>     pop rcx
   222                              <1>     ;Now that there is space in the buffer, we can do the copy!
   223                              <1> .doCopy:
   224 00000783 F3A4                <1>     rep movsb
   225                              <1>     return
    13                              <2> %%_ret:
    14 00000785 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   226                              <1> 
   227                              <1> stufBuf:
   228                              <1> ;Stuffs the workLine with a line of text from memory!
   229                              <1> ;Input: rsi -> Buffer to source the stuff from
   230                              <1> ;Output: Buffer stuffed. If line too long, truncated to the first 253 chars.
   231                              <1> ;       edx = Real length of line!
   232 00000786 488D3D(67020000)    <1>     lea rdi, workLine + 2   ;Go to the start of the text portion
   233 0000078D B9FF000000          <1>     mov ecx, 255
   234 00000792 31D2                <1>     xor edx, edx            ;Use as the char counter in the buffer
   235                              <1> .lp:
   236 00000794 AC                  <1>     lodsb
   237 00000795 AA                  <1>     stosb
   238 00000796 FFC2                <1>     inc edx     ;Copied one more char over
   239 00000798 3C0D                <1>     cmp al, CR  ;Was this a CR?
   240 0000079A 7404                <1>     je .eol     ;Exit if so
   241 0000079C FFC9                <1>     dec ecx     ;Else decrement from buffer counter
   242 0000079E 75F4                <1>     jnz .lp     ; and go again!
   243                              <1> .eol:
   244 000007A0 FFCA                <1>     dec edx     ;Drop the CR from the char count
   245 000007A2 8815(66020000)      <1>     mov byte [workLine + 1], dl ;Store the char count here
   246 000007A8 3C0D                <1>     cmp al, CR  ;Now check we are here due to having a valid EOL
   247                              <1>     rete        ;Exit if so
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000007AA 74(85)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   248 000007AC FFC2                <1>     inc edx
   249                              <1> .longLine:  ;Else scan for the EOL char
   250 000007AE AC                  <1>     lodsb   ;Get the next char
   251 000007AF FFC2                <1>     inc edx ;Keep track of the real length of the line
   252 000007B1 3C0D                <1>     cmp al, CR
   253 000007B3 75F9                <1>     jne .longLine   ;If not CR, keep searching
   254 000007B5 48FFCF              <1>     dec rdi ;Go back to the last char position in the buffer
   255 000007B8 AA                  <1>     stosb   ;Store the CR there
   256                              <1>     return  ;We stored max count in workLine+1 earlier. We are done
    13                              <2> %%_ret:
    14 000007B9 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   257                              <1> 
   258                              <1> doCmdChar:
   259                              <1> ;Handles command chars that are typed into the buffer. These chars are
   260                              <1> ; ^V<CHAR> where <CHAR> has to be a UC char to be treated as a command char.
   261                              <1> ;Assumes that rsi is pointing to the start of the data portion of a command line.
   262                              <1> ;Thus:  rsi -> Input buffer
   263                              <1> ;       rsi - 1 = Number of chars typed 
   264                              <1> ;       rsi - 2 = Input buffer length
   265 000007BA FC                  <1>     cld                         ;Ensure we are searching the right way
   266 000007BB 51                  <1>     push rcx
   267 000007BC 56                  <1>     push rsi
   268 000007BD 57                  <1>     push rdi
   269 000007BE 4889F7              <1>     mov rdi, rsi                ;Copy the pointer for scanning
   270 000007C1 0FB64EFF            <1>     movzx ecx, byte [rsi - 1]   ;Get number of chars typed in to scan
   271                              <1> .lp:
   272 000007C5 67E32A              <1>     jecxz .exit                 ;No more chars to handle, exit!
   273 000007C8 B816000000          <1>     mov eax, CMD                ;Scan for the ^V char in al
   274 000007CD F2AE                <1>     repne scasb
   275 000007CF 7521                <1>     jne .exit                   ;Ran out of chars to scan, exit!
   276                              <1> ;Here rdi points to the char after the quote char.
   277 000007D1 8A07                <1>     mov al, byte [rdi]  ;Get the quote char
   278 000007D3 E81E000000          <1>     call doControl  ;Convert into a control char if appropriate
   279 000007D8 8807                <1>     mov byte [rdi], al  ;Write back
   280                              <1> ;Save our position and count and pull the string up.
   281 000007DA 51                  <1>     push rcx
   282 000007DB 56                  <1>     push rsi
   283 000007DC 57                  <1>     push rdi
   284 000007DD 4889FE              <1>     mov rsi, rdi    ;Start copying from this replaced char
   285 000007E0 48FFCF              <1>     dec rdi         ;Store to the char before
   286 000007E3 FFC1                <1>     inc ecx         ;Copy over the CR too
   287 000007E5 F3A4                <1>     rep movsb
   288 000007E7 5F                  <1>     pop rdi
   289 000007E8 5E                  <1>     pop rsi
   290 000007E9 59                  <1>     pop rcx
   291 000007EA 67E305              <1>     jecxz .exit     ;If we terminated the line with a ^V<CR>, now exit
   292 000007ED FE4EFF              <1>     dec byte [rsi - 1]  ;Else drop one char from the count
   293 000007F0 EBD3                <1>     jmp short .lp   ;And keep scanning
   294                              <1> .exit:
   295 000007F2 5F                  <1>     pop rdi
   296 000007F3 5E                  <1>     pop rsi
   297 000007F4 59                  <1>     pop rcx
   298                              <1>     return
    13                              <2> %%_ret:
    14 000007F5 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   299                              <1> 
   300                              <1> doControl:
   301                              <1> ;Input: al = Possible control char. This has to be an uppercase char! 
   302 000007F6 50                  <1>     push rax
   303 000007F7 24E0                <1>     and al, 0E0h    ;Preserve upper three bits only (not used for chars)
   304 000007F9 3C40                <1>     cmp al, 40h     ;Check if only the middle (UC) was set!
   305 000007FB 58                  <1>     pop rax
   306                              <1>     retne
    53                              <2> cret ne
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000007FC 75(F5)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   307 000007FE 241F                <1>     and al, asciiMask   ;Convert into a control char
   308                              <1>     return
    13                              <2> %%_ret:
    14 00000800 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   309                              <1> 
   310                              <1> checkArgOrder:
   311                              <1> ;Checks two arguments to ensure the second one is 
   312                              <1> ; greater than the first.
   313                              <1> ;Input: bx = first argument
   314                              <1> ;       word [arg2] = second argument
   315                              <1> ;Output: If it returns, its ok. Else it resets the command loop
   316 00000801 66813D(DB010000)00- <1>     cmp word [arg2], 0
   316 00000809 00                  <1>
   317                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 0000080A 74(00)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   318 0000080C 663B1D(DB010000)    <1>     cmp bx, word [arg2]
   319                              <1>     retbe
    81                              <2> cret be
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000813 76(00)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   320 00000815 58                  <1>     pop rax     ;Pop off the return address
   321 00000816 E9850E0000          <1>     jmp printComErr
   322                              <1> 
   323                              <1> makeSpace:
   324                              <1> ;Makes space for a new string in the text
   325                              <1> ;Input: rdx -> Where in the arena we will move our text
   326                              <1> ;       rdi -> First byte we will be moving
   327                              <1> ;       bx = Line number we are making space for!
   328 0000081B 488B0D(28000000)    <1>     mov rcx, qword [eofPtr]
   329 00000822 4889CE              <1>     mov rsi, rcx    ;Copy in reverse, sourcing from the EOF ptr!!    
   330 00000825 4829F9              <1>     sub rcx, rdi    ;Get the count of bytes to copy
   331 00000828 FFC1                <1>     inc ecx         ;Including EOF
   332 0000082A 4889D7              <1>     mov rdi, rdx    
   333 0000082D FD                  <1>     std
   334 0000082E F3A4                <1>     rep movsb
   335 00000830 FC                  <1>     cld
   336 00000831 4887F7              <1>     xchg rsi, rdi   ;Swap the new EOF pointer and source
   337 00000834 48FFC7              <1>     inc rdi         ;Point to the first byte of made space
   338 00000837 4889F5              <1>     mov rbp, rsi    ;Setup to fall through now
   339                              <1> setLineVars:
   340                              <1> ;Sets the current line number, pointer and the new EOF pointer
   341                              <1> ;Input: bx = Current line number
   342                              <1> ;       rdi -> Space where this line is
   343                              <1> ;       rbp -> EOF char pointer
   344 0000083A 66891D(1E000000)    <1>     mov word [curLineNum], bx
   345 00000841 48893D(20000000)    <1>     mov qword [curLinePtr], rdi
   346 00000848 48892D(28000000)    <1>     mov qword [eofPtr], rbp
   347                              <1>     return
    13                              <2> %%_ret:
    14 0000084F C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   348                              <1> 
   349                              <1> findLine:
   350                              <1> ;Given a line number, tries to find the actual line.
   351                              <1> ;Input: ebx = Line number to search for, 0 means exhaust all chars!
   352                              <1> ;Output: ZF=ZE: rdi -> Ptr to the line
   353                              <1> ;               edx = Actual line number we are at
   354                              <1> ;               eax = Line number specified
   355                              <1> ;        ZF=NZ: Line not found. (i.e. beyond last line)
   356                              <1> ;               edx = Line number past current line number
   357                              <1> ;               rdi -> End of memory space
   358 00000850 0FB715(1E000000)    <1>     movzx edx, word [curLineNum]    ;Line to start counting from
   359 00000857 488B3D(20000000)    <1>     mov rdi, qword [curLinePtr]     ;Pointer to this line
   360 0000085E 39D3                <1>     cmp ebx, edx
   361                              <1>     rete    ;If we are already at the line we want to be at, return!
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000860 74(4F)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   362 00000862 7714                <1>     ja .prepSearch  
   363 00000864 85DB                <1>     test ebx, ebx   ;Are we in the goto last line case?
   364 00000866 7410                <1>     jz .prepSearch
   365                              <1> ;Else, we start scanning from the start of the arena!
   366 00000868 BA01000000          <1>     mov edx, 1
   367 0000086D 488B3D(0E000000)    <1>     mov rdi, qword [memPtr] 
   368 00000874 39D3                <1>     cmp ebx, edx
   369                              <1>     rete    ;If we want to find line 1, here we are!
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000876 74(4F)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   370                              <1> .prepSearch:
   371 00000878 488B0D(28000000)    <1>     mov rcx, qword [eofPtr]
   372 0000087F 4829F9              <1>     sub rcx, rdi    ;Turn ecx into count of chars left in buffer to scan
   373                              <1> findLineCore:
   374                              <1> ;Finds a line but from a presetup position as opposed to the global state!
   375                              <1> ;Input: rdi -> Line to check if it is terminated by a LF
   376                              <1> ;       ecx = Number of chars to check on
   377                              <1> ;       edx = Offset of line count to search for (line counter)
   378                              <1> ;       ebx = Count of lines to search for (0 means exhaust chars)
   379                              <1> ;Output:
   380                              <1> ;       al = LF
   381                              <1> ;       ZF=ZE: We read bx lines. rdi -> Past LF which terminated line
   382                              <1> ;       ZF=NZ: Ran out of chars
   383 00000882 B80A000000          <1>     mov eax, LF
   384                              <1> .lp:
   385 00000887 67E308              <1>     jecxz .exit ;Return w/o setting flags if we have no more chars left!
   386 0000088A F2AE                <1>     repne scasb
   387 0000088C FFC2                <1>     inc edx
   388 0000088E 39DA                <1>     cmp edx, ebx    ;Have we gone past bx lines yet?
   389 00000890 75F5                <1>     jne .lp    ;Scan the next line if not!!
   390                              <1> .exit:
   391                              <1>     return
    13                              <2> %%_ret:
    14 00000892 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   392                              <1> 
   393                              <1> strcpy:
   394                              <1> ;Copies a ASCIIZ string from one buffer to another. 
   395                              <1> ;Pointers don't move.
   396                              <1> ;Input: rsi -> Source Ptr
   397                              <1> ;       rdi -> Destination Ptr
   398 00000893 56                  <1>     push rsi
   399 00000894 57                  <1>     push rdi
   400                              <1> .cpChar:
   401 00000895 AC                  <1>     lodsb
   402 00000896 AA                  <1>     stosb
   403 00000897 84C0                <1>     test al, al ;Was this a nul char?
   404 00000899 75FA                <1>     jnz .cpChar
   405 0000089B 5F                  <1>     pop rdi
   406 0000089C 5E                  <1>     pop rsi
   407                              <1>     return
    13                              <2> %%_ret:
    14 0000089D C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   408                              <1> 
   409                              <1> checkEOF:
   410                              <1> ;Checks if we are at the EOF or if we hit an EOF char in the file.
   411                              <1> ;Input: ecx = Count of bytes
   412                              <1> ;       rdi -> Ptr to the start of the region we just read into memory
   413                              <1> ;       r10 = Original requested byte count
   414                              <1> ;Output: ZF=ZE => Found EOF in file (or ecx = 0)
   415                              <1> ;        ZF=NZ => No EOF found in file!
   416                              <1> ;       ecx = Count of relevant bytes in the buffer
   417 0000089E F605(04000000)FF    <1>     test byte [noEofChar], -1   ;If set, binary semantics!
   418 000008A5 7542                <1>     jnz .binScan
   419                              <1> ;Here we scan for ^Z char
   420 000008A7 57                  <1>     push rdi
   421 000008A8 51                  <1>     push rcx
   422 000008A9 B81A000000          <1>     mov eax, EOF
   423 000008AE 85C9                <1>     test ecx, ecx   ;If ecx is 0, skip the scan! Pretend we hit an EOF
   424 000008B0 7408                <1>     jz .ascNoEof
   425 000008B2 F2AE                <1>     repne scasb
   426 000008B4 7504                <1>     jne .ascNoEof
   427 000008B6 9C                  <1>     pushfq
   428 000008B7 FFC1                <1>     inc ecx         ;Increment by 1 to include the ptr to the EOF char itself!
   429 000008B9 9D                  <1>     popfq
   430                              <1> .ascNoEof:
   431 000008BA 89CF                <1>     mov edi, ecx    ;Save the byte count in edi (rdi)
   432 000008BC 59                  <1>     pop rcx         ;Get back the original byte count!
   433 000008BD 9C                  <1>     pushfq
   434 000008BE 29F9                <1>     sub ecx, edi    ;Get the number of chars into the string we are 
   435 000008C0 9D                  <1>     popfq
   436 000008C1 5F                  <1>     pop rdi
   437                              <1> .niceExit:
   438                              <1>     retnz               ;If we are here and ZF=NZ, exit as no EOF hit
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000008C2 75(9D)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   439                              <1> ;Now we adjust the end of the file, if the end of the file was a ^Z
   440                              <1> ; so that if the last char was not an LF, we add a CRLF pair
   441 000008C4 9C                  <1>     pushfq
   442 000008C5 57                  <1>     push rdi
   443 000008C6 4801CF              <1>     add rdi, rcx    ;Go the the end of the buffer
   444 000008C9 48FFCF              <1>     dec rdi
   445 000008CC 48393D(0E000000)    <1>     cmp qword [memPtr], rdi ;Are we at the head of the buffer?
   446 000008D3 7405                <1>     je .putCRLF ;If so, forcefully place a CRLF pair
   447 000008D5 803F0A              <1>     cmp byte [rdi], LF
   448 000008D8 740C                <1>     je .exit
   449                              <1> .putCRLF:
   450 000008DA 66C747010D0A        <1>     mov word [rdi + 1], CRLF
   451 000008E0 81C102000000        <1>     add ecx, 2  ;We added two chars to the count
   452                              <1> .exit:
   453 000008E6 5F                  <1>     pop rdi
   454 000008E7 9D                  <1>     popfq
   455                              <1>     return
    13                              <2> %%_ret:
    14 000008E8 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   456                              <1> .binScan:
   457                              <1> ;Here we deal with binary semantics
   458 000008E9 4439D1              <1>     cmp ecx, r10d   ;If we read less bytes than desired, check if an EOF present!
   459 000008EC 7205                <1>     jb .binLess
   460 000008EE 31C0                <1>     xor eax, eax
   461 000008F0 FFC0                <1>     inc eax         ;Clear ZF
   462                              <1>     return
    13                              <2> %%_ret:
    14 000008F2 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   463                              <1> .binLess:
   464 000008F3 67E308              <1>     jecxz .binEofExit ;If ecx = 0, just adjust end and exit!
   465 000008F6 803C0F1A            <1>     cmp byte [rdi + rcx], EOF   ;Was this byte an EOF char?
   466 000008FA 7502                <1>     jne .binEofExit
   467 000008FC FFC9                <1>     dec ecx             ;Drop it from the count.
   468                              <1> .binEofExit:
   469 000008FE 31C0                <1>     xor eax, eax
   470 00000900 EBC0                <1>     jmp short .niceExit
   471                              <1> 
   472                              <1> 
   473                              <1> delBkup:
   474                              <1> ;Finally, we delete the backup if it exists. If it doesn't delete
   475                              <1> ; for some reason, might be problematic later but not a big issue.
   476                              <1> ;If returns with CF=CY, know that the backup didn't delete...
   477                              <1> ;Preserves all registers!
   478 00000902 F605(39000000)FF    <1>     test byte [bkupDel], -1     ;If set, backup already deleted
   479                              <1>     retnz
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000909 75(F2)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   480 0000090B F605(38000000)FF    <1>     test byte [modFlag], -1   ;If clear, buffer has not been modified.
   481                              <1>     retz                        
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000912 74(F2)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   482 00000914 F605(03000000)FF    <1>     test byte [newFileFlag], -1 ;If the file is new then it has no backup!
   483                              <1>     retnz
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 0000091B 75(F2)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   484 0000091D C605(39000000)FF    <1>     mov byte [bkupDel], -1      ;Now deleting backup
   485 00000924 50                  <1>     push rax
   486 00000925 52                  <1>     push rdx
   487 00000926 57                  <1>     push rdi
   488 00000927 488B3D(46010000)    <1>     mov rdi, qword [fileExtPtr]
   489 0000092E B842414B00          <1>     mov eax, "BAK"
   490 00000933 AB                  <1>     stosd
   491 00000934 488D15(BE000000)    <1>     lea rdx, bkupfile
   492 0000093B B800410000          <1>     mov eax, 4100h
   493 00000940 CD21                <1>     int 21h
   494 00000942 5F                  <1>     pop rdi
   495 00000943 5A                  <1>     pop rdx
   496 00000944 58                  <1>     pop rax
   497                              <1>     retnc  ;Could overwrite first byte of this function with a ret 0:)
    61                              <2> cret nc
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000945 73(F2)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   498                              <1>     ;I like my idea... but no, we need the flag.
   499 00000947 488D15(1A010000)    <1>     lea rdx, badBackDel
   500 0000094E E8150C0000          <1>     call printString
   501                              <1>     retToDOS errBadBak
    94 00000953 B8044C0000          <2>  mov eax, 04C00h | %1
    95 00000958 CD21                <2>  int 21h
   502                              <1> 
   503                              <1> 
   504                              <1> parseEntry:
   505                              <1> ;Parses a single command line argument.
   506                              <1> ;. means current line
   507                              <1> ;+ means positive number offset from current line
   508                              <1> ;- means negative number offset from current line
   509                              <1> ;# means line after the last line in file ALWAYS.
   510                              <1> ; This is represented in the argument var as the 
   511                              <1> ; word 0FFFFh.
   512                              <1> ;A naked number is interpreted as a line number 
   513                              <1> ; directly.
   514                              <1> ;Maximum input value per argument: 65529
   515                              <1> ;--------------------------------------------
   516                              <1> ;Input: rsi -> String to parse
   517                              <1> ;Output: (e)bx = Value of argument
   518                              <1> ;          rsi -> First char past the end of arg
   519                              <1> ;--------------------------------------------
   520 0000095A E89F000000          <1>     call skipSpaces ;Move rsi past first non-space char and get al = First char
   521 0000095F 3C2B                <1>     cmp al, "+" ;Positive offset from current line
   522 00000961 7444                <1>     je .plus
   523 00000963 3C2D                <1>     cmp al, "-" ;Negative offset from current line
   524 00000965 7454                <1>     je .minus
   525 00000967 3C2E                <1>     cmp al, "." ;Current line, advance ptr to command terminator
   526 00000969 746E                <1>     je .dot
   527 0000096B 3C23                <1>     cmp al, "#" ;Last line (-1), advance ptr to command terminator
   528 0000096D 7478                <1>     je .pound
   529 0000096F 31DB                <1>     xor ebx, ebx
   530 00000971 31C9                <1>     xor ecx, ecx
   531                              <1> .getArg:
   532 00000973 3C30                <1>     cmp al, "0"
   533 00000975 7222                <1>     jb .endOfArg
   534 00000977 3C39                <1>     cmp al, "9"
   535 00000979 771E                <1>     ja .endOfArg
   536 0000097B 81FB99190000        <1>     cmp ebx, 0FFFFh/0Ah ;If we are gonna go above the max, fail now
   537 00000981 0F83190D0000        <1>     jae printComErr
   538 00000987 FFC9                <1>     dec ecx ;Indicate we have a valid digit
   539 00000989 2C30                <1>     sub al, "0"
   540 0000098B 678D1C9B            <1>     lea ebx, dword [4*ebx + ebx]    ;5*ebx
   541 0000098F D1E3                <1>     shl ebx, 1          ;2*5*ebx = 10*ebx
   542 00000991 0FB6C0              <1>     movzx eax, al
   543 00000994 01C3                <1>     add ebx, eax
   544 00000996 AC                  <1>     lodsb   ;Get the next char
   545 00000997 EBDA                <1>     jmp short .getArg
   546                              <1> .endOfArg:
   547 00000999 85C9                <1>     test ecx, ecx
   548                              <1>     retz    ;If no char provided, exit silently. Var already 0
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26                              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29 0000099B 7501                <3>  j%-1 short %%a
    30                              <3>  return
    13                              <4> %%_ret:
    14 0000099D C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   549 0000099E 85DB                <1>     test ebx, ebx   
   550 000009A0 0F84FA0C0000        <1>     jz printComErr  ;Dont allow 0 as an argument
   551                              <1>     return
    13                              <2> %%_ret:
    14 000009A6 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   552                              <1> .plus:
   553 000009A7 E844000000          <1>     call .validSpecial
   554 000009AC E8A9FFFFFF          <1>     call parseEntry ;Now parse the entry again
   555 000009B1 0FB705(1E000000)    <1>     movzx eax, word [curLineNum]
   556 000009B8 01C3                <1>     add ebx, eax    ;Only the low word is considered!!
   557                              <1>     return
    13                              <2> %%_ret:
    14 000009BA C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   558                              <1> .minus:
   559 000009BB E830000000          <1>     call .validSpecial
   560 000009C0 E895FFFFFF          <1>     call parseEntry ;Now parse the entry again, get result in ebx
   561 000009C5 0FB705(1E000000)    <1>     movzx eax, word [curLineNum]
   562 000009CC 29D8                <1>     sub eax, ebx    ;Now get the differnece and ...
   563 000009CE 89C3                <1>     mov ebx, eax    ;save the difference in ebx
   564 000009D0 B801000000          <1>     mov eax, 1
   565 000009D5 0F48D8              <1>     cmovs ebx, eax  ;If the difference is less than 0, return to line 1
   566                              <1>     return
    13                              <2> %%_ret:
    14 000009D8 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   567                              <1> .dot:
   568 000009D9 E812000000          <1>     call .validSpecial
   569 000009DE 0FB71D(1E000000)    <1>     movzx ebx, word [curLineNum]    ;Goto current line (starts from 1)
   570 000009E5 AC                  <1>     lodsb
   571                              <1>     return
    13                              <2> %%_ret:
    14 000009E6 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   572                              <1> .pound:
   573 000009E7 E804000000          <1>     call .validSpecial
   574 000009EC FFCB                <1>     dec ebx         ;Go to last line
   575 000009EE AC                  <1>     lodsb
   576                              <1>     return
    13                              <2> %%_ret:
    14 000009EF C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   577                              <1> .validSpecial:
   578                              <1> ;Returns if it is a valid case to do so. Else no
   579 000009F0 803D(D8010000)04    <1>     cmp byte [argCnt], 4    ;Argument 2 is for the count
   580 000009F7 0F84A30C0000        <1>     je printComErr
   581                              <1>     return
    13                              <2> %%_ret:
    14 000009FD C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   582                              <1> 
   583                              <1> skipSpaces:
   584                              <1> ;Also skips tabs
   585                              <1> ;Input: rsi must point to the start of the data string
   586                              <1> ;Output: rsi points to the first non-space char
   587                              <1> ;           al = First non-space char
   588 000009FE AC                  <1>     lodsb
   589 000009FF 3C20                <1>     cmp al, " "
   590 00000A01 74FB                <1>     je short skipSpaces  
   591 00000A03 3C09                <1>     cmp al, TAB
   592 00000A05 74F7                <1>     je short skipSpaces
   593                              <1>     return
    13                              <2> %%_ret:
    14 00000A07 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   594                              <1> 
   595                              <1> ;---------------------------------------------------------------------------
   596                              <1> ;                  !!!! IMPORTANT Int 23h HANDLERS !!!!
   597                              <1> ;---------------------------------------------------------------------------
   598                              <1> i23hXfr:
   599 00000A08 0FB71D(ED040000)    <1>     movzx ebx, word [xfrHdl]
   600 00000A0F B8003E0000          <1>     mov eax, 3E00h  ;Close the handle
   601 00000A14 CD21                <1>     int 21h
   602                              <1>     ;Now reset the stack and proceed as normal
   603                              <1> i23hInsert:
   604                              <1> ;^C handler for insert!
   605 00000A16 488D25(40060000)    <1>     lea rsp, stackTop
   606 00000A1D FC                  <1>     cld
   607 00000A1E E8510B0000          <1>     call printCRLF
   608 00000A23 E848010000          <1>     call insertLine.cleanInsert ;We now reset the state of the memory
   609 00000A28 E9E4FAFFFF          <1>     jmp nextCmd     ;Now go to the next command in the command line!
   610                              <1> 
   611                              <1> i23h:
   612                              <1> ;^C handler. Reset the stack pointer and jump to get command
   613 00000A2D 488D25(40060000)    <1>     lea rsp, stackTop
   614 00000A34 FC                  <1>     cld
   615 00000A35 E83A0B0000          <1>     call printCRLF
   616 00000A3A E9CDF9FFFF          <1>     jmp getCommand  ;Now jump to get the command
    36                                  %include "./Source/edfunc.asm"
     1                              <1> ;This is where the main user selectable routines are
     2                              <1> ;All arguments specified are signed words
     3                              <1> 
     4                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     5                              <1> ; File editing functions
     6                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     7                              <1> 
     8                              <1> editLine:
     9                              <1> ;Displays a line and allows it to be edited
    10                              <1> ;--------------------------------------------
    11                              <1> ;Invoked by: [line]
    12                              <1> ;--------------------------------------------
    13 00000A3F 803D(D8010000)01    <1>     cmp byte [argCnt], 1
    14 00000A46 0F85540C0000        <1>     jne printComErr
    15 00000A4C 48FF0D(D0010000)    <1>     dec qword [charPtr] ;Adjust ptr to point to the CR or ;
    16 00000A53 0FB71D(D9010000)    <1>     movzx ebx, word [arg1]  ;Get the line number
    17 00000A5A 85DB                <1>     test ebx, ebx
    18 00000A5C 7509                <1>     jnz .notNext
    19                              <1>     ;If 0, means next line
    20 00000A5E 0FB71D(1E000000)    <1>     movzx ebx, word [curLineNum]    ;Get the current line number
    21 00000A65 FFC3                <1>     inc ebx ;and go to the next line
    22                              <1> .notNext:
    23 00000A67 E8E4FDFFFF          <1>     call findLine   ;rdi points to the end of memory selected line
    24                              <1>     ;If we return with ZF set, we proceed because we found the line,
    25                              <1>     ; else we simply return!
    26 00000A6C 668915(1E000000)    <1>     mov word [curLineNum], dx
    27 00000A73 48893D(20000000)    <1>     mov qword [curLinePtr], rdi
    28                              <1>     retnz   ;If the line specified was past the end, we return now
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000A7A 75(07)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    29 00000A7C 483B3D(28000000)    <1>     cmp rdi, qword [eofPtr]
    30                              <1>     rete    ;Return if these are equal!
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000A83 74(07)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    31 00000A85 4889FE              <1>     mov rsi, rdi    ;Save the current line ptr on the stack
    32 00000A88 56                  <1>     push rsi
    33 00000A89 E8F8FCFFFF          <1>     call stufBuf    ;Stuff the line pointed to by rsi into the buffer
    34 00000A8E 5E                  <1>     pop rsi         ;Get back the curLinePtr in rsi
    35 00000A8F 8915(67030000)      <1>     mov dword [workLen], edx    ;Store the real length into the var
    36 00000A95 E8610B0000          <1>     call printLine      
    37 00000A9A E8ED0A0000          <1>     call printLineNum
    38 00000A9F 488D15(65020000)    <1>     lea rdx, workLine
    39 00000AA6 B8000A0000          <1>     mov eax, 0A00h  ;Edit magic woo
    40 00000AAB CD21                <1>     int 21h
    41 00000AAD E8C90A0000          <1>     call printLF
    42 00000AB2 807A0100            <1>     cmp byte [rdx + 1], 0   ;If just a CR input, return with no edit!
    43                              <1>     retz
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26                              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29 00000AB6 7501                <3>  j%-1 short %%a
    30                              <3>  return
    13                              <4> %%_ret:
    14 00000AB8 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
    44 00000AB9 488D7202            <1>     lea rsi, qword [rdx + 2]    ;Go to the string portion immediately
    45 00000ABD E8F8FCFFFF          <1>     call doCmdChar
    46 00000AC2 488B3D(20000000)    <1>     mov rdi, qword [curLinePtr] ;Point to the line we have edited
    47 00000AC9 0FB64A01            <1>     movzx ecx, byte [rdx + 1]   ;Get the adjusted string length in ecx
    48 00000ACD 8B15(67030000)      <1>     mov edx, dword [workLen]    ;Get the old line length in edx
    49 00000AD3 E960FCFFFF          <1>     jmp replaceLine
    50                              <1> 
    51                              <1> insertLine:
    52                              <1> ;Inserts a line
    53                              <1> ;--------------------------------------------
    54                              <1> ;Invoked by: [line]I
    55                              <1> ;--------------------------------------------
    56 00000AD8 803D(D8010000)01    <1>     cmp byte [argCnt], 1
    57 00000ADF 0F85BB0B0000        <1>     jne printComErr
    58 00000AE5 488D152AFFFFFF      <1>     lea rdx, i23hInsert ;Set to the insert handler
    59 00000AEC B823250000          <1>     mov eax, 2523h
    60 00000AF1 CD21                <1>     int 21h
    61 00000AF3 0FB71D(D9010000)    <1>     movzx ebx, word [arg1]  ;Get the line number
    62 00000AFA 85DB                <1>     test ebx, ebx
    63 00000AFC 7507                <1>     jnz .notNext
    64                              <1>     ;If 0, means next line
    65 00000AFE 0FB71D(1E000000)    <1>     movzx ebx, word [curLineNum]    ;Get the current line number
    66                              <1> .notNext:
    67 00000B05 E846FDFFFF          <1>     call findLine   ;Set line number in dx and rdi -> Space in memory!
    68 00000B0A 89D3                <1>     mov ebx, edx    ;Move the actual line number into ebx
    69 00000B0C 488B15(30000000)    <1>     mov rdx, qword [endOfArena]
    70 00000B13 E803FDFFFF          <1>     call makeSpace  ;Make space to insert new line!
    71                              <1> .inLp:
    72 00000B18 E81DFDFFFF          <1>     call setLineVars
    73 00000B1D E86A0A0000          <1>     call printLineNum
    74 00000B22 488D15(65020000)    <1>     lea rdx, workLine
    75 00000B29 B8000A0000          <1>     mov eax, 0A00h  ;Full on edit mode
    76 00000B2E CD21                <1>     int 21h
    77 00000B30 E8460A0000          <1>     call printLF
    78                              <1>     ;Check if the first char in the buffer is a EOF
    79 00000B35 488D7202            <1>     lea rsi, qword [rdx + 2]    ;Go to the string portion immediately
    80 00000B39 803E1A              <1>     cmp byte [rsi], EOF         ;Apparent EDLIN behaviour, terminate insert so!
    81 00000B3C 7432                <1>     je .cleanInsert
    82 00000B3E E877FCFFFF          <1>     call doCmdChar              ;Preserves rdi, the curLinePtr
    83 00000B43 0FB64EFF            <1>     movzx ecx, byte [rsi - 1]   ;Get the number of chars typed in
    84 00000B47 4889FA              <1>     mov rdx, rdi                
    85 00000B4A FFC1                <1>     inc ecx                     ;Make space for terminating LF too
    86 00000B4C 4801CA              <1>     add rdx, rcx                ;Check if we will go out of bounds
    87 00000B4F 483B15(30000000)    <1>     cmp rdx, qword [endOfArena]
    88 00000B56 730E                <1>     jae .inBad
    89 00000B58 4839EA              <1>     cmp rdx, rbp                ;Are we past file Eof?
    90 00000B5B 7309                <1>     jae .inBad                  ;Jump if so
    91 00000B5D F3A4                <1>     rep movsb                   ;Else copy from edit line to space made
    92 00000B5F B00A                <1>     mov al, LF
    93 00000B61 AA                  <1>     stosb                       ;Store the line feed too
    94 00000B62 FFC3                <1>     inc ebx                     ;Go to next line :)
    95 00000B64 EBB2                <1>     jmp short .inLp
    96                              <1> .inBad:
    97 00000B66 E805000000          <1>     call .cleanInsert
    98 00000B6B E9270B0000          <1>     jmp printMemErr
    99                              <1> .cleanInsert: 
   100                              <1> ;Move the lines after the insertion point back to where they need to be :)
   101 00000B70 488B35(28000000)    <1>     mov rsi, qword [eofPtr] 
   102 00000B77 488B3D(20000000)    <1>     mov rdi, qword [curLinePtr]
   103 00000B7E 488B0D(30000000)    <1>     mov rcx, qword [endOfArena]
   104 00000B85 4829F1              <1>     sub rcx, rsi    ;Get the number of bytes to copy high again
   105 00000B88 48FFC6              <1>     inc rsi         ;Go to char past EOF to source chars from
   106 00000B8B F3A4                <1>     rep movsb
   107 00000B8D 48FFCF              <1>     dec rdi         ;Go back to the EOF char itself
   108 00000B90 48893D(28000000)    <1>     mov qword [eofPtr], rdi
   109 00000B97 488D158FFEFFFF      <1>     lea rdx, i23h
   110 00000B9E B823250000          <1>     mov eax, 2523h  ;Set Interrupt handler for Int 23h
   111 00000BA3 CD21                <1>     int 21h
   112                              <1>     return
    13                              <2> %%_ret:
    14 00000BA5 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   113                              <1> 
   114                              <1> deleteLines:
   115                              <1> ;Deletes one or a range of lines
   116                              <1> ;--------------------------------------------
   117                              <1> ;Invoked by: [line][,line]D
   118                              <1> ;--------------------------------------------
   119 00000BA6 803D(D8010000)02    <1>     cmp byte [argCnt], 2
   120 00000BAD 0F87ED0A0000        <1>     ja printComErr
   121 00000BB3 0FB71D(D9010000)    <1>     movzx ebx, word [arg1]
   122 00000BBA 85DB                <1>     test ebx, ebx
   123 00000BBC 750E                <1>     jnz .notCur
   124 00000BBE 0FB71D(1E000000)    <1>     movzx ebx, word [curLineNum]
   125 00000BC5 66891D(D9010000)    <1>     mov word [arg1], bx ;Store it explicitly for later
   126                              <1> .notCur:
   127 00000BCC 0FB71D(DB010000)    <1>     movzx ebx, word [arg2]
   128 00000BD3 85DB                <1>     test ebx, ebx
   129 00000BD5 750E                <1>     jnz .goDel
   130 00000BD7 0FB71D(D9010000)    <1>     movzx ebx, word [arg1]     ;Use arg1 as the range end
   131 00000BDE 66891D(DB010000)    <1>     mov word [arg2], bx
   132                              <1> .goDel:
   133 00000BE5 0FB71D(D9010000)    <1>     movzx ebx, word [arg1]
   134 00000BEC E810FCFFFF          <1>     call checkArgOrder  ;Now we check if our args are ok
   135 00000BF1 E85AFCFFFF          <1>     call findLine   ;If ZF=NZ, start of del not found, just return
   136                              <1>     retnz
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000BF6 75(A5)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   137 00000BF8 53                  <1>     push rbx    ;Save the line number
   138 00000BF9 57                  <1>     push rdi    ;And pointer to it
   139 00000BFA 0FB71D(DB010000)    <1>     movzx ebx, word [arg2]
   140 00000C01 FFC3                <1>     inc ebx     ;Range so end at the line after
   141 00000C03 E848FCFFFF          <1>     call findLine   ;Get the end of the copy ptr
   142 00000C08 4889FE              <1>     mov rsi, rdi    ;Source chars from this line
   143 00000C0B 5F                  <1>     pop rdi
   144 00000C0C 5B                  <1>     pop rbx
   145 00000C0D 66891D(1E000000)    <1>     mov word [curLineNum], bx   ;Now update the line number
   146 00000C14 48893D(20000000)    <1>     mov qword [curLinePtr], rdi ;This is where we will be copying to
   147 00000C1B 488B0D(28000000)    <1>     mov rcx, qword [eofPtr]
   148 00000C22 4829F1              <1>     sub rcx, rsi    ;Get the number of chars to copy up
   149 00000C25 FFC1                <1>     inc ecx         ;Add one char for the eof char itself
   150 00000C27 FC                  <1>     cld 
   151 00000C28 F3A4                <1>     rep movsb       ;Copy the whole file up
   152 00000C2A 48FFCF              <1>     dec rdi         ;Point to the EOF char itself
   153 00000C2D 48893D(28000000)    <1>     mov qword [eofPtr], rdi
   154                              <1>     return
    13                              <2> %%_ret:
    14 00000C34 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   155                              <1> 
   156                              <1> 
   157                              <1> transferLines:
   158                              <1> ;Writes the lines specified to the specified file
   159                              <1> ;--------------------------------------------
   160                              <1> ;Invoked by: [line]T[d:]filename
   161                              <1> ;--------------------------------------------
   162 00000C35 803D(D8010000)01    <1>     cmp byte [argCnt], 1
   163 00000C3C 0F855E0A0000        <1>     jne printComErr
   164 00000C42 E8B7FDFFFF          <1>     call skipSpaces ;Move rsi to the first char of the xfrspec
   165 00000C47 48FFCE              <1>     dec rsi         ;Go to the first char
   166 00000C4A 488D15(6D040000)    <1>     lea rdx, xfrName
   167 00000C51 4889D7              <1>     mov rdi, rdx
   168                              <1> .nameCp:
   169 00000C54 AC                  <1>     lodsb
   170 00000C55 3C20                <1>     cmp al, SPC
   171 00000C57 740F                <1>     je .cpOk
   172 00000C59 3C09                <1>     cmp al, TAB
   173 00000C5B 740B                <1>     je .cpOk
   174 00000C5D 3C0D                <1>     cmp al, CR
   175 00000C5F 7407                <1>     je .cpOk
   176 00000C61 3C3B                <1>     cmp al, ";"
   177 00000C63 7403                <1>     je .cpOk
   178 00000C65 AA                  <1>     stosb
   179 00000C66 EBEC                <1>     jmp short .nameCp
   180                              <1> .cpOk:
   181 00000C68 C60700              <1>     mov byte [rdi], 0   ;Store terminating null
   182 00000C6B 48FFCE              <1>     dec rsi             ;Now go to the char which terminated the copy
   183 00000C6E 488935(D0010000)    <1>     mov qword [charPtr], rsi    ;And store this as the new continuation ptr
   184 00000C75 B8003D0000          <1>     mov eax, 3D00h      ;Open file pointed to by rdx for reading
   185 00000C7A CD21                <1>     int 21h
   186 00000C7C 731B                <1>     jnc .fileOpen
   187 00000C7E 663D0200            <1>     cmp ax, errFnf
   188 00000C82 488D15(8D000000)    <1>     lea rdx, badFindStr ;String for if the file is not found
   189 00000C89 488D1D(71000000)    <1>     lea rbx, badDrvStr  ;Else just say drive or fnf!
   190 00000C90 480F45D3            <1>     cmovne rdx, rbx
   191 00000C94 E90E0A0000          <1>     jmp printErr    ;Print the string in rdx
   192                              <1> .fileOpen:
   193 00000C99 668905(ED040000)    <1>     mov word [xfrHdl], ax   ;Save the handle
   194                              <1>     ;Transfer lines works like insert lines, in that it is inserting lines
   195                              <1>     ; but from a separate file. We therefore set up a custom ^C handler 
   196                              <1>     ; and cleanup like insert if it is invoked!
   197 00000CA0 B823250000          <1>     mov eax, 2523h  ;Setup int 23h for xfr
   198 00000CA5 488D155CFDFFFF      <1>     lea rdx, i23hXfr
   199 00000CAC CD21                <1>     int 21h
   200 00000CAE 0FB71D(D9010000)    <1>     movzx ebx, word [arg1]
   201 00000CB5 85DB                <1>     test ebx, ebx
   202 00000CB7 7507                <1>     jnz .notCur
   203 00000CB9 0FB71D(1E000000)    <1>     movzx ebx, word [curLineNum]    ;Get the current line number ptr
   204                              <1> .notCur:
   205 00000CC0 E88BFBFFFF          <1>     call findLine   ;Get actual line number in dx, and ptr in rdi
   206 00000CC5 89D3                <1>     mov ebx, edx
   207 00000CC7 488B15(30000000)    <1>     mov rdx, qword [endOfArena]     ;Copy to the end of the arena
   208 00000CCE E848FBFFFF          <1>     call makeSpace  ;And jiggle it over
   209 00000CD3 488B15(20000000)    <1>     mov rdx, qword [curLinePtr] ;Read data into here now
   210 00000CDA 488B0D(28000000)    <1>     mov rcx, qword [eofPtr]
   211 00000CE1 29D1                <1>     sub ecx, edx    ;Get the number of chars of space we have to read in
   212 00000CE3 51                  <1>     push rcx
   213 00000CE4 B8003F0000          <1>     mov eax, 3F00h
   214 00000CE9 0FB71D(ED040000)    <1>     movzx ebx, word [xfrHdl]
   215 00000CF0 CD21                <1>     int 21h
   216 00000CF2 5A                  <1>     pop rdx     ;Get the count back into rdx
   217 00000CF3 89C1                <1>     mov ecx, eax    ;Move the count into ecx
   218 00000CF5 39C2                <1>     cmp edx, eax
   219 00000CF7 7713                <1>     ja .fullXfr
   220                              <1>     ;We copied exactly the size of the arena, assume this means the whole 
   221                              <1>     ; file may not have been copied. We still proceed though
   222 00000CF9 488D15(93010000)    <1>     lea rdx, badMergeStr
   223 00000D00 488B0D(20000000)    <1>     mov rcx, qword [curLinePtr]
   224 00000D07 E915000000          <1>     jmp .endXfr
   225                              <1> .fullXfr:
   226 00000D0C 48030D(20000000)    <1>     add rcx, qword [curLinePtr] ;Turn into offset from start of line
   227 00000D13 4889CE              <1>     mov rsi, rcx
   228 00000D16 48FFCE              <1>     dec rsi ;Go to the last char we read in
   229 00000D19 AC                  <1>     lodsb
   230 00000D1A 3C1A                <1>     cmp al, EOF
   231 00000D1C 7503                <1>     jne .endXfr
   232 00000D1E 48FFC9              <1>     dec rcx ;Drop a byte
   233                              <1> .endXfr:
   234 00000D21 4889CF              <1>     mov rdi, rcx        ;Copy to the curLinePtr pos
   235 00000D24 488B35(28000000)    <1>     mov rsi, qword [eofPtr]
   236 00000D2B 48FFC6              <1>     inc rsi             ;Start copying from the stored data past the eofPtr
   237 00000D2E 488B0D(30000000)    <1>     mov rcx, qword [endOfArena]
   238 00000D35 4829F1              <1>     sub rcx, rsi
   239 00000D38 FFC1                <1>     inc ecx             ;Add EOF char to the count
   240 00000D3A F3A4                <1>     rep movsb
   241 00000D3C 48FFCF              <1>     dec rdi             ;Go back to the EOF char
   242 00000D3F 48893D(28000000)    <1>     mov qword [eofPtr], rdi
   243 00000D46 0FB71D(ED040000)    <1>     movzx ebx, word [xfrHdl]
   244 00000D4D B8003E0000          <1>     mov eax, 3E00h      ;Close handle!
   245 00000D52 CD21                <1>     int 21h
   246                              <1>     return
    13                              <2> %%_ret:
    14 00000D54 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   247                              <1> 
   248                              <1> 
   249                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   250                              <1> ; File block moving functions (copying and cutting and pasting)
   251                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   252                              <1> ;Both following functions need 3 arguments, but empty args are permitted!
   253                              <1> moveLines:
   254                              <1> ;Moves a block of lines elsewhere (non overlapping moves only)
   255                              <1> ;--------------------------------------------
   256                              <1> ;Invoked by: [line],[line],lineM
   257                              <1> ;--------------------------------------------
   258 00000D55 803D(D8010000)03    <1>     cmp byte [argCnt], 3
   259 00000D5C 0F853E090000        <1>     jne printComErr
   260 00000D62 C605(EF040000)FF    <1>     mov byte [movCpFlg], -1
   261 00000D69 E914000000          <1>     jmp copyLines.common
   262                              <1> copyLines:
   263                              <1> ;Duplicates a line or a range of lines to a position specifed 
   264                              <1> ;   (non-overlapping) 
   265                              <1> ;--------------------------------------------
   266                              <1> ;Invoked by: [line],[line],line[,count]C
   267                              <1> ;--------------------------------------------
   268 00000D6E 803D(D8010000)03    <1>     cmp byte [argCnt], 3    ;This can be 3 or 4 arguments!
   269 00000D75 0F8225090000        <1>     jb printComErr
   270 00000D7B C605(EF040000)00    <1>     mov byte [movCpFlg], 0
   271                              <1> .common:
   272                              <1> ;arg1 = Start line of range for copy, default to current line
   273                              <1> ;arg2 = End line of range for copy, default to line after current line
   274                              <1> ;arg3 = Line to place it at, no default, cant be 0!
   275                              <1> ;arg4 = Number of times to consecutively repeat the copy (copy only)
   276 00000D82 0FB71D(DD010000)    <1>     movzx ebx, word [arg3]  ;Check the mandatory argument
   277 00000D89 85DB                <1>     test ebx, ebx   ;Are we 0?
   278 00000D8B 488D15(61020000)    <1>     lea rdx, badDestStr
   279 00000D92 0F840F090000        <1>     jz printErr
   280 00000D98 0FB71D(D9010000)    <1>     movzx ebx, word [arg1]
   281 00000D9F 85DB                <1>     test ebx, ebx
   282 00000DA1 7513                <1>     jnz .gotStart
   283 00000DA3 0FB71D(1E000000)    <1>     movzx ebx, word [curLineNum]
   284 00000DAA E852FAFFFF          <1>     call checkArgOrder  ;Check that this is before arg2
   285 00000DAF 66891D(D9010000)    <1>     mov word [arg1], bx
   286                              <1> .gotStart:
   287 00000DB6 E895FAFFFF          <1>     call findLine   ;Get in rdi the ptr to the first argument
   288 00000DBB 0F85DF080000        <1>     jnz printComErr ;If the line is not found, we gotta complain!
   289 00000DC1 48893D(F0040000)    <1>     mov qword [blkPtrSrc], rdi  ;Save the ptr to the line!
   290 00000DC8 0FB71D(DB010000)    <1>     movzx ebx, word [arg2]
   291 00000DCF 85DB                <1>     test ebx, ebx
   292 00000DD1 750E                <1>     jnz .gotEnd
   293                              <1>     ;Set the default line!
   294 00000DD3 0FB71D(1E000000)    <1>     movzx ebx, word [curLineNum] 
   295 00000DDA 66891D(DB010000)    <1>     mov word [arg2], bx
   296                              <1> .gotEnd:
   297 00000DE1 53                  <1>     push rbx            ;Save this line number
   298 00000DE2 E869FAFFFF          <1>     call findLine       ;Ensure the line in bx exists
   299 00000DE7 5B                  <1>     pop rbx
   300 00000DE8 0F85B2080000        <1>     jnz printComErr     ;Again, if the line not found, complain!
   301 00000DEE FFC3                <1>     inc ebx             ;Now increment the line number to get line after
   302 00000DF0 E85BFAFFFF          <1>     call findLine   ;This can be end of arena since this is end of copy blk
   303 00000DF5 48893D(F8040000)    <1>     mov qword [blkPtrEnd], rdi     
   304                              <1> ;We mightve changed the second argument so double check it!
   305 00000DFC 0FB71D(D9010000)    <1>     movzx ebx, word [arg1]
   306 00000E03 663B1D(DB010000)    <1>     cmp bx, word [arg2]
   307 00000E0A 0F8790080000        <1>     ja printComErr
   308                              <1> ;Now we check against the third line. It must not be in the range 
   309                              <1> ; specified, else error (cannot overlap copies or moves!!!)
   310 00000E10 0FB71D(DD010000)    <1>     movzx ebx, word [arg3]    ;Get the storage line
   311 00000E17 663B1D(D9010000)    <1>     cmp bx, word [arg1]     ;arg3 <= arg1?
   312 00000E1E 760D                <1>     jbe .argsOk
   313 00000E20 663B1D(DB010000)    <1>     cmp bx, word [arg2]     ;arg3 > arg2 ?
   314 00000E27 0F8673080000        <1>     jbe printComErr
   315                              <1> .argsOk:
   316 00000E2D 488B0D(F8040000)    <1>     mov rcx, qword [blkPtrEnd]
   317 00000E34 482B0D(F0040000)    <1>     sub rcx, qword [blkPtrSrc]  ;Get the size of one block that we will move
   318 00000E3B 890D(08050000)      <1>     mov dword [blkSize], ecx
   319 00000E41 0FB705(DF010000)    <1>     movzx eax, word [arg4]      ;Get the count length
   320 00000E48 85C0                <1>     test eax, eax
   321 00000E4A 750E                <1>     jnz .havCnt                 ;We have a given count
   322 00000E4C B801000000          <1>     mov eax, 1                  ;Else, default to 1
   323 00000E51 668905(DF010000)    <1>     mov word [arg4], ax
   324 00000E58 EB0C                <1>     jmp short .noCount          ;ecx has the copysize, skip the multiply!
   325                              <1> .havCnt:
   326                              <1> ;Here we compute the copySize as a multiple of blkSize
   327 00000E5A F7E1                <1>     mul ecx
   328 00000E5C 85D2                <1>     test edx, edx   ;Is this larger than a dword (should never happen!)
   329 00000E5E 0F8533080000        <1>     jnz printMemErr ;Bad count argument!!
   330 00000E64 89C1                <1>     mov ecx, eax    ;Make ecx the size of the copy
   331                              <1> .noCount:
   332 00000E66 890D(0C050000)      <1>     mov dword [copySize], ecx
   333                              <1> ;Now, can we fit our new section of text in memory?
   334 00000E6C 488B1D(28000000)    <1>     mov rbx, qword [eofPtr]
   335 00000E73 488B15(30000000)    <1>     mov rdx, qword [endOfArena]
   336 00000E7A 4829DA              <1>     sub rdx, rbx
   337 00000E7D 39CA                <1>     cmp edx, ecx
   338 00000E7F 0F8212080000        <1>     jb printMemErr  ;Insufficient memory error!!
   339                              <1> ;Finally, get the line we will place copy at!
   340 00000E85 0FB71D(DD010000)    <1>     movzx ebx, word [arg3]
   341 00000E8C E8BFF9FFFF          <1>     call findLine
   342 00000E91 48893D(00050000)    <1>     mov qword [cpyPtrDest], rdi ;Now save ptr to the line we copy to!
   343                              <1> ;Now make space for one load of the copy
   344 00000E98 488B35(28000000)    <1>     mov rsi, qword [eofPtr]
   345 00000E9F 4889F1              <1>     mov rcx, rsi
   346 00000EA2 4829F9              <1>     sub rcx, rdi    ;Get the number of bytes we will shift
   347 00000EA5 FFC1                <1>     inc ecx         ;Add EOF
   348 00000EA7 4889F7              <1>     mov rdi, rsi    ;This is the destination
   349 00000EAA 8B05(0C050000)      <1>     mov eax, dword [copySize]
   350 00000EB0 4801C7              <1>     add rdi, rax    ;Go to the destination
   351 00000EB3 48893D(28000000)    <1>     mov qword [eofPtr], rdi ;This is the new eof position!
   352 00000EBA FD                  <1>     std
   353 00000EBB F3A4                <1>     rep movsb   ;Now copy in reverse :)
   354 00000EBD FC                  <1>     cld
   355                              <1> ;Adjust blkPtrs if they were in this region.
   356 00000EBE 488B1D(00050000)    <1>     mov rbx, qword [cpyPtrDest]
   357 00000EC5 483B1D(F0040000)    <1>     cmp rbx, qword [blkPtrSrc]
   358 00000ECC 7714                <1>     ja .ptrsOk
   359 00000ECE 8B0D(0C050000)      <1>     mov ecx, dword [copySize]    ;Add this amount to the ptrs
   360 00000ED4 48010D(F0040000)    <1>     add qword [blkPtrSrc], rcx
   361 00000EDB 48010D(F8040000)    <1>     add qword [blkPtrEnd], rcx
   362                              <1> .ptrsOk:
   363 00000EE2 0FB71D(DF010000)    <1>     movzx ebx, word [arg4]  ;Get adjusted count to use as counter
   364 00000EE9 488B3D(00050000)    <1>     mov rdi, qword [cpyPtrDest] ;Write to here!
   365                              <1> .cpLp:
   366 00000EF0 8B0D(08050000)      <1>     mov ecx, dword [blkSize]
   367 00000EF6 488B35(F0040000)    <1>     mov rsi, qword [blkPtrSrc]  ;Start the copy from here
   368 00000EFD F3A4                <1>     rep movsb
   369 00000EFF FFCB                <1>     dec ebx
   370 00000F01 75ED                <1>     jnz .cpLp   ;If this is zero, finish!
   371 00000F03 803D(EF040000)00    <1>     cmp byte [movCpFlg], 0  ;Was this a move or a copy?
   372 00000F0A 744F                <1>     je .copyDone
   373                              <1> ;Now pull everything back over the source of the move
   374 00000F0C 488B3D(F0040000)    <1>     mov rdi, qword [blkPtrSrc]
   375 00000F13 488B35(F8040000)    <1>     mov rsi, qword [blkPtrEnd]
   376 00000F1A 488B0D(28000000)    <1>     mov rcx, qword [eofPtr]
   377 00000F21 4829F1              <1>     sub rcx, rsi    ;Get the number of bytes to move 
   378 00000F24 48FFC1              <1>     inc rcx         ;Include EOF
   379 00000F27 F3A4                <1>     rep movsb
   380 00000F29 48FFCF              <1>     dec rdi         ;Go back to the EOF char itself
   381 00000F2C 48893D(28000000)    <1>     mov qword [eofPtr], rdi
   382 00000F33 0FB71D(DD010000)    <1>     movzx ebx, word [arg3]
   383 00000F3A 663B1D(D9010000)    <1>     cmp bx, word [arg1] ;Was this in the range of the move?
   384 00000F41 7618                <1>     jbe .copyDone
   385                              <1>     ;If it was, add the difference - 1
   386 00000F43 66031D(D9010000)    <1>     add bx, word [arg1]
   387 00000F4A 662B1D(DB010000)    <1>     sub bx, word [arg2]
   388 00000F51 66FFCB              <1>     dec bx 
   389 00000F54 66891D(DD010000)    <1>     mov word [arg3], bx
   390                              <1> .copyDone:
   391 00000F5B 0FB71D(DD010000)    <1>     movzx ebx, word [arg3]
   392 00000F62 E8E9F8FFFF          <1>     call findLine
   393 00000F67 48893D(20000000)    <1>     mov qword [curLinePtr], rdi
   394 00000F6E 66891D(1E000000)    <1>     mov word [curLineNum], bx
   395                              <1>     return
    13                              <2> %%_ret:
    14 00000F75 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   396                              <1> 
   397                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   398                              <1> ; File searching functions
   399                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   400                              <1> 
   401                              <1> searchText:
   402                              <1> ;Searches text for a string
   403                              <1> ;--------------------------------------------
   404                              <1> ;Invoked by: [line][,line][?]S[string]
   405                              <1> ;--------------------------------------------
   406 00000F76 803D(D8010000)02    <1>     cmp byte [argCnt], 2
   407 00000F7D 0F871D070000        <1>     ja printComErr
   408 00000F83 C605(10050000)01    <1>     mov byte [srchMode], 1      ;Search from current line + 1
   409 00000F8A C605(11050000)01    <1>     mov byte [findMod], 1       ;Set that we are searching!
   410 00000F91 E804F6FFFF          <1>     call findFirst
   411 00000F96 0F85F2060000        <1>     jnz printLineNotFoundErr
   412                              <1> .lp:
   413 00000F9C 488B35(1F050000)    <1>     mov rsi, qword [fndLinePtr]
   414 00000FA3 0FB71D(27050000)    <1>     movzx ebx, word [fndLineNum]
   415 00000FAA E84C060000          <1>     call printLine      ;Print this line!
   416 00000FAF 488B3D(17050000)    <1>     mov rdi, qword [fndStrPtr]
   417 00000FB6 8B0D(29050000)      <1>     mov ecx, dword [fndSrchLen]
   418 00000FBC B00A                <1>     mov al, LF
   419 00000FBE F2AE                <1>     repne scasb
   420 00000FC0 0F85C8060000        <1>     jne printLineNotFoundErr
   421 00000FC6 48893D(17050000)    <1>     mov qword [fndStrPtr], rdi
   422 00000FCD 48893D(1F050000)    <1>     mov qword [fndLinePtr], rdi
   423 00000FD4 890D(29050000)      <1>     mov dword [fndSrchLen], ecx ;Remaining count for search region
   424 00000FDA 66FF05(27050000)    <1>     inc word [fndLineNum]   ;Goto next line now!
   425 00000FE1 E87CF5FFFF          <1>     call okPrompt
   426 00000FE6 740D                <1>     jz findSetLine
   427 00000FE8 E891F6FFFF          <1>     call findNext
   428 00000FED 0F859B060000        <1>     jnz printLineNotFoundErr    ;If no more found, print error message!
   429 00000FF3 EBA7                <1>     jmp short .lp   ;Else, output it and loop again
   430                              <1> 
   431                              <1> findSetLine:
   432 00000FF5 0FB71D(27050000)    <1>     movzx ebx, word [fndLineNum]
   433 00000FFC 803D(11050000)00    <1>     cmp byte [findMod], 0   ;If we are search, we need to decrement
   434 00001003 7402                <1>     je .main
   435 00001005 FFCB                <1>     dec ebx ;Advance from current line to the last line we found on!
   436                              <1> .main:
   437 00001007 E844F8FFFF          <1>     call findLine
   438 0000100C 66891D(1E000000)    <1>     mov word [curLineNum], bx
   439 00001013 48893D(20000000)    <1>     mov qword [curLinePtr], rdi
   440                              <1>     return
    13                              <2> %%_ret:
    14 0000101A C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   441                              <1> 
   442                              <1> replaceText:
   443                              <1> ;Replaces all matching strings with specified string (NO REGEX)
   444                              <1> ;--------------------------------------------
   445                              <1> ;Invoked by: [line][,line][?]R[string]<EOF>[string]
   446                              <1> ;--------------------------------------------
   447 0000101B 803D(D8010000)02    <1>     cmp byte [argCnt], 2
   448 00001022 0F8778060000        <1>     ja printComErr
   449 00001028 C605(10050000)01    <1>     mov byte [srchMode], 1  ;Search by default from current line + 1
   450 0000102F C605(11050000)00    <1>     mov byte [findMod], 0   ;Set that we are replacing the string!
   451 00001036 E85FF5FFFF          <1>     call findFirst
   452 0000103B 0F854D060000        <1>     jnz printLineNotFoundErr
   453                              <1> .lp:
   454 00001041 488B35(1F050000)    <1>     mov rsi, qword [fndLinePtr]
   455 00001048 E839F7FFFF          <1>     call stufBuf    ;Get the line length in edx
   456 0000104D 0FB70D(13050000)    <1>     movzx ecx, word [fndLenOld]
   457 00001054 29CA                <1>     sub edx, ecx
   458 00001056 0FB70D(15050000)    <1>     movzx ecx, word [fndLenNew]
   459 0000105D 01CA                <1>     add edx, ecx
   460 0000105F 81FAFE000000        <1>     cmp edx, 254
   461 00001065 0F87C0000000        <1>     ja .tooLong
   462 0000106B 0FB71D(27050000)    <1>     movzx ebx, word [fndLineNum]
   463 00001072 52                  <1>     push rdx    ;Save the line length
   464 00001073 E814050000          <1>     call printLineNum   ;Print the line number in ebx
   465 00001078 5A                  <1>     pop rdx
   466                              <1>     ;Now build the new string in the buffer to print as a replacement
   467 00001079 488B0D(17050000)    <1>     mov rcx, qword [fndStrPtr]
   468 00001080 488B35(1F050000)    <1>     mov rsi, qword [fndLinePtr]
   469 00001087 4829F1              <1>     sub rcx, rsi    ;Get the number of chars into the line our string is at
   470 0000108A 48FFC9              <1>     dec rcx         ;Drop the first char of the string we will replace
   471 0000108D 488D3D(6B030000)    <1>     lea rdi, spareLine  ;Build the new line in this buffer 
   472 00001094 E89E000000          <1>     call .cpyString
   473 00001099 56                  <1>     push rsi
   474 0000109A 488D35(AF050000)    <1>     lea rsi, fndString2 + 1
   475 000010A1 0FB70D(15050000)    <1>     movzx ecx, word [fndLenNew]
   476 000010A8 E88A000000          <1>     call .cpyString
   477 000010AD 5E                  <1>     pop rsi
   478 000010AE 0FB70D(13050000)    <1>     movzx ecx, word [fndLenOld]
   479 000010B5 4801CE              <1>     add rsi, rcx
   480 000010B8 89D1                <1>     mov ecx, edx    ;Move the remaining chars count into ecx
   481 000010BA 81C102000000        <1>     add ecx, 2      ;Add 2 for the CR/LF
   482 000010C0 E872000000          <1>     call .cpyString ;Write the last part of the line in
   483 000010C5 31C0                <1>     xor eax, eax
   484 000010C7 AA                  <1>     stosb           ;Store the null terminator too
   485 000010C8 E8AB050000          <1>     call prnAsciiz
   486 000010CD E890F4FFFF          <1>     call okPrompt
   487 000010D2 754A                <1>     jnz .gotoNext
   488 000010D4 E81CFFFFFF          <1>     call findSetLine
   489 000010D9 488B3D(17050000)    <1>     mov rdi, qword [fndStrPtr]
   490 000010E0 48FFCF              <1>     dec rdi
   491 000010E3 488D35(AF050000)    <1>     lea rsi, fndString2 + 1
   492 000010EA 0FB715(13050000)    <1>     movzx edx, word [fndLenOld]
   493 000010F1 0FB70D(15050000)    <1>     movzx ecx, word [fndLenNew]
   494 000010F8 FFC9                <1>     dec ecx
   495 000010FA 48010D(17050000)    <1>     add qword [fndStrPtr], rcx  ;Go to the end of the found string
   496 00001101 FFC1                <1>     inc ecx
   497 00001103 FFCA                <1>     dec edx
   498 00001105 2915(29050000)      <1>     sub dword [fndSrchLen], edx ;
   499 0000110B 730A                <1>     jae .overspill
   500 0000110D C705(29050000)0000- <1>     mov dword [fndSrchLen], 0
   500 00001115 0000                <1>
   501                              <1> .overspill:
   502 00001117 FFC2                <1>     inc edx
   503 00001119 E81AF6FFFF          <1>     call replaceLine
   504                              <1> .gotoNext:
   505 0000111E E85BF5FFFF          <1>     call findNext
   506                              <1>     retnz
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26                              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29 00001123 7401                <3>  j%-1 short %%a
    30                              <3>  return
    13                              <4> %%_ret:
    14 00001125 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   507 00001126 E916FFFFFF          <1>     jmp .lp
   508                              <1> .tooLong:
   509 0000112B 488D15(94020000)    <1>     lea rdx, badLineLen
   510 00001132 E970050000          <1>     jmp printErr
   511                              <1> .cpyString:
   512                              <1> ;Copies a string, ensures we have the last char in al when we return
   513                              <1> ;Copies ecx number of chars
   514 00001137 85C9                <1>     test ecx, ecx
   515                              <1>     retz
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00001139 74(25)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   516                              <1> .cpsLp:
   517 0000113B AC                  <1>     lodsb
   518 0000113C AA                  <1>     stosb
   519 0000113D FFCA                <1>     dec edx ;Decrement total line length
   520 0000113F FFC9                <1>     dec ecx ;Decrement line portion length
   521 00001141 75F8                <1>     jnz .cpsLp
   522                              <1>     return
    13                              <2> %%_ret:
    14 00001143 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   523                              <1> 
   524                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   525                              <1> ; File listing functions
   526                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   527                              <1> 
   528                              <1> listLines:
   529                              <1> ;Prints a line or a number of lines.
   530                              <1> ;Defaults to from current line print 23 lines.
   531                              <1> ;Doesnt change the current line!
   532                              <1> ;--------------------------------------------
   533                              <1> ;Invoked by: [line][,line]L
   534                              <1> ;--------------------------------------------
   535 00001144 803D(D8010000)02    <1>     cmp byte [argCnt], 2
   536 0000114B 0F874F050000        <1>     ja printComErr
   537 00001151 0FB71D(D9010000)    <1>     movzx ebx, word [arg1]
   538 00001158 85DB                <1>     test ebx, ebx
   539 0000115A 7514                <1>     jnz .notCur ;If not the default, we do as told
   540                              <1>     ;Else, default behaviour
   541 0000115C 0FB71D(1E000000)    <1>     movzx ebx, word [curLineNum]
   542 00001163 81EB0B000000        <1>     sub ebx, 11 ;Start printing 11 lines before the current line!
   543 00001169 7705                <1>     ja .notCur  
   544 0000116B BB01000000          <1>     mov ebx, 1
   545                              <1> .notCur:
   546 00001170 E8DBF6FFFF          <1>     call findLine
   547                              <1>     retnz   ;Return if the line not found!
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00001175 75(43)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   548 00001177 4889FE              <1>     mov rsi, rdi
   549 0000117A 0FB73D(DB010000)    <1>     movzx edi, word [arg2]  ;Get the last line to print
   550 00001181 FFC7                <1>     inc edi
   551 00001183 29DF                <1>     sub edi, ebx            ;Get the difference!
   552 00001185 0F8775040000        <1>     ja printLines   
   553 0000118B BF17000000          <1>     mov edi, 23     ;Else the default
   554 00001190 E96B040000          <1>     jmp printLines  ;Return through printLines!
   555                              <1> 
   556                              <1> pageLines:
   557                              <1> ;Prints a page of lines
   558                              <1> ;Defaults to from current line to print 23 lines
   559                              <1> ;Changes the current line to the last line printed!
   560                              <1> ;--------------------------------------------
   561                              <1> ;Invoked by: [line][,line]P
   562                              <1> ;--------------------------------------------
   563 00001195 803D(D8010000)02    <1>     cmp byte [argCnt], 2
   564 0000119C 0F87FE040000        <1>     ja printComErr
   565 000011A2 31DB                <1>     xor ebx, ebx    ;Set the pointer to the end of the file firstly
   566 000011A4 E8A7F6FFFF          <1>     call findLine   
   567                              <1>     ;Use r10 to keep track of the last line in the file that we will set
   568 000011A9 4989D2              <1>     mov r10, rdx
   569 000011AC 0FB71D(D9010000)    <1>     movzx ebx, word [arg1]
   570 000011B3 85DB                <1>     test ebx, ebx
   571 000011B5 7511                <1>     jnz .notCur
   572 000011B7 0FB71D(1E000000)    <1>     movzx ebx, word [curLineNum]
   573 000011BE 81FB01000000        <1>     cmp ebx, 1  ;If the first line is 1, keep it there
   574 000011C4 7402                <1>     je .notCur
   575 000011C6 FFC3                <1>     inc ebx     ;Else go to the line after
   576                              <1> .notCur:
   577 000011C8 4C39D3              <1>     cmp rbx, r10
   578                              <1>     reta    ;If we specify past the last line, do nothing
    73                              <2> cret a
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26                              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29 000011CB 7601                <3>  j%-1 short %%a
    30                              <3>  return
    13                              <4> %%_ret:
    14 000011CD C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   579 000011CE 0FB715(DB010000)    <1>     movzx edx, word [arg2]  
   580 000011D5 85D2                <1>     test edx, edx   ;Did the user give what line to stop printing on?
   581 000011D7 7508                <1>     jnz .arg2Given 
   582                              <1> ;vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
   583                              <1> ;Here is where the screen width is computed when we do dynamic 
   584                              <1> ; screen size stuff
   585 000011D9 89DA                <1>     mov edx, ebx
   586 000011DB 81C216000000        <1>     add edx, 22     ;Else its current line + 23
   587                              <1> ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   588                              <1> .arg2Given:
   589 000011E1 FFC2                <1>     inc edx         ;Get that last line
   590 000011E3 4C39D2              <1>     cmp rdx, r10    ;Is it past the end of the file?
   591 000011E6 7603                <1>     jbe .okRange
   592 000011E8 4C89D2              <1>     mov rdx, r10    ;Else, use r10 as the last line
   593                              <1> .okRange:
   594 000011EB 52                  <1>     push rdx        ;Save the end line
   595 000011EC 53                  <1>     push rbx        ;and the start line
   596 000011ED 89D3                <1>     mov ebx, edx    ;Now setup the pointers to point to the last line
   597 000011EF FFCB                <1>     dec ebx         
   598 000011F1 E85AF6FFFF          <1>     call findLine   ;Get the actual line number in dx and ptr in rdi
   599 000011F6 668915(1E000000)    <1>     mov word [curLineNum], dx
   600 000011FD 48893D(20000000)    <1>     mov qword [curLinePtr], rdi
   601 00001204 5B                  <1>     pop rbx         ;Get back the actual start line
   602 00001205 E846F6FFFF          <1>     call findLine   ;Now find the first line!
   603 0000120A 4889FE              <1>     mov rsi, rdi    ;This is the source of the copy
   604 0000120D 5F                  <1>     pop rdi         ;Get the end line count in edi
   605 0000120E 29DF                <1>     sub edi, ebx    ;Get the number of lines to print in edi
   606 00001210 E9EB030000          <1>     jmp printLines  ;Return through printLines!
   607                              <1> 
   608                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   609                              <1> ; File IO control functions
   610                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   611                              <1> 
   612                              <1> appendLines:
   613                              <1> ;If the file is not fully loaded in arena, allows you to load 
   614                              <1> ; the next portion into the arena. Essentially ignores the 
   615                              <1> ; input and always fills up to the 3/4 limit.
   616                              <1> ;--------------------------------------------
   617                              <1> ;Invoked by: [n]A (number of bytes to read)
   618                              <1> ;--------------------------------------------
   619 00001215 803D(D8010000)01    <1>     cmp byte [argCnt], 1
   620 0000121C 0F857E040000        <1>     jne printComErr
   621 00001222 F605(05000000)FF    <1>     test byte [eofReached], -1
   622 00001229 0F8538010000        <1>     jnz .outEofStr   ;Print the eof reached string
   623 0000122F 488B15(28000000)    <1>     mov rdx, qword [eofPtr]
   624 00001236 803D(D9010000)00    <1>     cmp byte [arg1], 0          ;Arg <> 0 means we fill the arena
   625 0000123D 7509                <1>     jne .argGiven
   626 0000123F 483B15(16000000)    <1>     cmp rdx, qword [fillPtr]    ;Are we at/past the fill point?
   627                              <1>     retnb   ;Return if so!
    69                              <2> cret nb
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00001246 73(CD)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   628                              <1> .argGiven:
   629                              <1> ;rdx -> The start of the read in buffer
   630 00001248 488B0D(30000000)    <1>     mov rcx, qword [endOfArena] ;Fill the arena
   631 0000124F 4829D1              <1>     sub rcx, rdx        ;Get the number of bytes to read save one paragraph
   632 00001252 4881E910000000      <1>     sub rcx, 16         ;This is so appending CRLF's or EOF's won't segfault
   633 00001259 0F8438040000        <1>     jz printMemErr      ;If we @ end of arena, free some space!!
   634 0000125F 4989CA              <1>     mov r10, rcx        ;Use r10 to save byte count we want to read in
   635 00001262 0FB71D(3A000000)    <1>     movzx ebx, word [readHdl]
   636 00001269 B8003F0000          <1>     mov eax, 3F00h
   637 0000126E CD21                <1>     int 21h
   638 00001270 39C8                <1>     cmp eax, ecx
   639 00001272 7426                <1>     je .notEof
   640                              <1>     ;Check this is really the eof (by trying to read one more byte)
   641 00001274 50                  <1>     push rax    ;Save the byte count
   642 00001275 4801C2              <1>     add rdx, rax
   643 00001278 B901000000          <1>     mov ecx, 1
   644 0000127D B8003F0000          <1>     mov eax, 3F00h
   645 00001282 CD21                <1>     int 21h
   646 00001284 89C1                <1>     mov ecx, eax
   647 00001286 58                  <1>     pop rax     ;Get original byte count back
   648 00001287 0F8224040000        <1>     jc badReadFail
   649 0000128D 85C9                <1>     test ecx, ecx   ;Did we read bytes?
   650 0000128F 7507                <1>     jnz .notEofInc  ;If not, inc byte count!
   651 00001291 C605(05000000)FF    <1>     mov byte [eofReached], -1   ;Else, set the flag!!
   652                              <1> .notEofInc:
   653 00001298 FFC0                <1>     inc eax
   654                              <1> .notEof:
   655 0000129A 4801C2              <1>     add rdx, rax        ;rax has the number of bytes we have read
   656 0000129D 89C1                <1>     mov ecx, eax        ;Save the byte count in ecx
   657 0000129F 488B3D(28000000)    <1>     mov rdi, qword [eofPtr] ;Point rdi to the start of the read in region
   658 000012A6 4989CB              <1>     mov r11, rcx            ;Save real byte count in r11 temporarily
   659 000012A9 E8F0F5FFFF          <1>     call checkEOF
   660 000012AE 7507                <1>     jnz .noSetEof   ;Set the byte here if ZF=ZE on return
   661 000012B0 C605(05000000)FF    <1>     mov byte [eofReached], -1   ;to keep it all on the same level!
   662                              <1> .noSetEof:
   663 000012B7 0FB71D(D9010000)    <1>     movzx ebx, word [arg1]  ;Get the line number to read in to
   664 000012BE 85DB                <1>     test ebx, ebx
   665 000012C0 7521                <1>     jnz .fndLine    ;If we are searching for line 0, go to the end
   666 000012C2 4889F8              <1>     mov rax, rdi
   667 000012C5 4801C8              <1>     add rax, rcx    ;Move the the end of the text we read in
   668 000012C8 483B05(16000000)    <1>     cmp rax, qword [fillPtr]
   669 000012CF 7612                <1>     jbe .fndLine    ;If we are leq than fill point, scan for the lnnum  in bx!
   670                              <1>     ;Else we search for one line past the fillPtr at most
   671 000012D1 4889C1              <1>     mov rcx, rax
   672 000012D4 488B3D(16000000)    <1>     mov rdi, qword [fillPtr]
   673 000012DB 4829F9              <1>     sub rcx, rdi    ;Get the excess of bytes to scan for the line
   674 000012DE BB01000000          <1>     mov ebx, 1      ;Make sure we count only 1 line!
   675                              <1> .fndLine:
   676 000012E3 31D2                <1>     xor edx, edx    ;Set the line counter to start at 0
   677 000012E5 E898F5FFFF          <1>     call findLineCore   ;Returns al = LF, rdi -> either LF or first char after ecx
   678 000012EA 3847FF              <1>     cmp byte [rdi - 1], al
   679 000012ED 742F                <1>     je .lineOk
   680                              <1> ;Here we ran out of chars to scan through
   681 000012EF F605(05000000)FF    <1>     test byte [eofReached], -1
   682 000012F6 7510                <1>     jnz .findPrevLine   ;If not at EOF, and ran out of chars, go to prev line
   683                              <1>     ;Else, at EOF and ran out of chars, add a CRLF
   684 000012F8 B80D0A0000          <1>     mov eax, CRLF   ;Store in the empty space pointed to by rdi
   685 000012FD 66AB                <1>     stosw    
   686 000012FF 4981C302000000      <1>     add r11, 2  ;Added two more chars to the count
   687 00001306 EB16                <1>     jmp short .lineOk
   688                              <1> .findPrevLine:
   689 00001308 FFCA                <1>     dec edx     ;Remember we have to dec the line number
   690 0000130A 48FFCF              <1>     dec rdi     ;Point to the char previous to start searching at
   691 0000130D 8B0D(06000000)      <1>     mov ecx, dword [arenaSize]  ;Get the size of the allocation to search thru
   692 00001313 FD                  <1>     std
   693 00001314 F2AE                <1>     repne scasb ;Scan for the LF in al
   694 00001316 FC                  <1>     cld
   695 00001317 4881C702000000      <1>     add rdi, 2  ;Go to first char past it
   696                              <1> .lineOk:
   697 0000131E C6071A              <1>     mov byte [rdi], EOF ;Add the terminating EOF char here!
   698 00001321 4C89D9              <1>     mov rcx, r11    ;Get back the real byte count
   699 00001324 48030D(0E000000)    <1>     add rcx, qword [memPtr] ;Get ptr to last byte we actually read in
   700 0000132B 4829F9              <1>     sub rcx, rdi    ;Get the excess number of chars we added since reading in
   701 0000132E 48873D(28000000)    <1>     xchg qword [eofPtr], rdi    ;Swap the old and new EOF char ptrs
   702 00001335 4801CF              <1>     add rdi, rcx    ;Adjust file ptr by amount we read in but ignored
   703 00001338 4885FF              <1>     test rdi, rdi
   704 0000133B 741E                <1>     jz .noIgnore    ;We ignored no bytes read in, proceed
   705                              <1>     ;Else, we are at the previous line, so move file ptr there!
   706 0000133D 53                  <1>     push rbx
   707 0000133E 52                  <1>     push rdx
   708 0000133F 4889FA              <1>     mov rdx, rdi
   709 00001342 48B9FFFFFFFFFFFFFF- <1>     mov rcx, -1
   709 0000134B FF                  <1>
   710 0000134C B801420000          <1>     mov eax, 4201h  ;Seek from current position by the amount in dx
   711 00001351 CD21                <1>     int 21h
   712 00001353 5A                  <1>     pop rdx
   713 00001354 5B                  <1>     pop rbx
   714 00001355 0F8256030000        <1>     jc badReadFail
   715                              <1> .noIgnore:
   716 0000135B 39D3                <1>     cmp ebx, edx    ;Is the line number specified = line number we are at?
   717 0000135D 7515                <1>     jne .checkEnd
   718 0000135F C605(05000000)00    <1>     mov byte [eofReached], 0    ;Reset byte if this is the case (adding new lines)
   719                              <1>     return
    13                              <2> %%_ret:
    14 00001366 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   720                              <1> .outEofStr:
   721 00001367 488D15(47000000)    <1>     lea rdx, eofStr
   722 0000136E E8F5010000          <1>     call printString
   723                              <1>     return
    13                              <2> %%_ret:
    14 00001373 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   724                              <1> .checkEnd:
   725 00001374 F605(05000000)FF    <1>     test byte [eofReached], -1
   726 0000137B 75EA                <1>     jnz .outEofStr
   727 0000137D F605(64020000)FF    <1>     test byte [noAppendErr], -1 ;Ignore EOF errors on initial load!
   728                              <1>     retnz 
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00001384 75(73)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   729 00001386 E90C030000          <1>     jmp printMemErr
   730                              <1> 
   731                              <1> writeLines:
   732                              <1> ;Writes the current arena to disk. If no 
   733                              <1> ; n specified, EDLIN writes lines until
   734                              <1> ; 1/4 of the arena is free.
   735                              <1> ;--------------------------------------------
   736                              <1> ;Invoked by: [n]W (number of bytes to write)
   737                              <1> ;--------------------------------------------
   738                              <1> ;When invoked, must delete the backup if it not already deleted.
   739 0000138B 803D(D8010000)01    <1>     cmp byte [argCnt], 1
   740 00001392 0F8708030000        <1>     ja printComErr
   741 00001398 0FB71D(D9010000)    <1>     movzx ebx, word [arg1]
   742 0000139F 85DB                <1>     test ebx, ebx
   743 000013A1 7529                <1>     jnz .goFindLine
   744                              <1>     ;If 0, means, write everything from 1/4 onwards
   745 000013A3 8B0D(0A000000)      <1>     mov ecx, dword [freeCnt]    ;Get the count of 1/4 of the arena
   746 000013A9 488B3D(28000000)    <1>     mov rdi, qword [eofPtr]
   747 000013B0 4829CF              <1>     sub rdi, rcx    ;Move rdi back by a quarter
   748                              <1>     retbe           ;If the result is leq 0, fail (never will happen)
    81                              <2> cret be
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000013B3 76(73)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   749 000013B5 483B3D(0E000000)    <1>     cmp rdi, qword [memPtr] ;Are we pointing before the start of the arena
   750                              <1>     retbe           ;Return as we have nothing to write!
    81                              <2> cret be
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000013BC 76(73)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   751                              <1>     ;rdi now points back by a quarter
   752 000013BE 31D2                <1>     xor edx, edx    ;Init to "line 0"
   753 000013C0 BB01000000          <1>     mov ebx, 1      ;Find the end of the line we are
   754 000013C5 E8B8F4FFFF          <1>     call findLineCore
   755 000013CA EB07                <1>     jmp short .prepWrite
   756                              <1> .goFindLine:
   757 000013CC FFC3                <1>     inc ebx     ;Find line 1 (user said 0, this means 1 for us!)
   758 000013CE E87DF4FFFF          <1>     call findLine
   759                              <1> .prepWrite:
   760 000013D3 E82AF5FFFF          <1>     call delBkup    ;Delete the backup, all regs preserved
   761 000013D8 4889F9              <1>     mov rcx, rdi    ;rdi points to up to where to do the write
   762 000013DB 488B15(0E000000)    <1>     mov rdx, qword [memPtr] ;Start writing from here
   763 000013E2 4829D1              <1>     sub rcx, rdx    ;Get the byte offset into the arena
   764 000013E5 0FB71D(3C000000)    <1>     movzx ebx, word [writeHdl]
   765 000013EC B800400000          <1>     mov eax, 4000h
   766 000013F1 CD21                <1>     int 21h
   767 000013F3 0F82CB020000        <1>     jc fullDiskFail
   768 000013F9 39C8                <1>     cmp eax, ecx
   769 000013FB 0F85C3020000        <1>     jne fullDiskFail
   770                              <1>     ;Now pull up the rest of the arena and reset the internal line numbers
   771 00001401 4889FE              <1>     mov rsi, rdi    ;Source chars from here
   772 00001404 488B3D(0E000000)    <1>     mov rdi, qword [memPtr]
   773 0000140B 48893D(20000000)    <1>     mov qword [curLinePtr], rdi
   774 00001412 66C705(1E000000)01- <1>     mov word [curLineNum], 1    ;Go back to line 1 again
   774 0000141A 00                  <1>
   775 0000141B 488B0D(28000000)    <1>     mov rcx, qword [eofPtr]
   776 00001422 4829F1              <1>     sub rcx, rsi    ;Get the number of bytes left in the arena to pull up
   777 00001425 FFC1                <1>     inc ecx         ;Copy the EOF marker too
   778 00001427 FC                  <1>     cld 
   779 00001428 F3A4                <1>     rep movsb
   780 0000142A 48FFCF              <1>     dec rdi         ;Go back to EOF
   781 0000142D 48893D(28000000)    <1>     mov qword [eofPtr], rdi
   782                              <1>     return
    13                              <2> %%_ret:
    14 00001434 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   783                              <1> 
   784                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   785                              <1> ; Exit functions
   786                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   787                              <1> 
   788                              <1> endEdit:
   789                              <1> ;Inserts a EOF char at the end of the file if one not already present
   790                              <1> ; renames the original file (if applicable) to have .bak ending and
   791                              <1> ; renames the working file to the name originally specified.
   792                              <1> ;--------------------------------------------
   793                              <1> ;Invoked by: E
   794                              <1> ;--------------------------------------------
   795 00001435 803D(D8010000)01    <1>     cmp byte [argCnt], 1
   796 0000143C 0F855E020000        <1>     jne printComErr
   797 00001442 803D(D9010000)00    <1>     cmp byte [arg1], 0
   798 00001449 0F8551020000        <1>     jne printComErr
   799 0000144F F605(02000000)FF    <1>     test byte [roFlag], -1  ;If we are readonly, delete $$$ and quit
   800 00001456 0F85EA000000        <1>     jnz quit.roQuit
   801 0000145C C605(64020000)FF    <1>     mov byte [noAppendErr], -1  ;Suppress errors again
   802                              <1> .writeLp:
   803 00001463 BBFFFFFFFF          <1>     mov ebx, -1             ;Write out max lines
   804 00001468 E85FFFFFFF          <1>     call writeLines.goFindLine
   805 0000146D F605(05000000)FF    <1>     test byte [eofReached], -1  ;Are we at EOF yet?
   806 00001474 7517                <1>     jnz .writeDone  ;If yes, we are done writing to disk
   807 00001476 C605(D8010000)01    <1>     mov byte [argCnt], 1    ;Else we keep reading the file
   808 0000147D 66C705(D9010000)FF- <1>     mov word [arg1], -1     ;Now fill the arena with lines
   808 00001485 FF                  <1>
   809 00001486 E88AFDFFFF          <1>     call appendLines
   810 0000148B EBD6                <1>     jmp short .writeLp      ;And write them out again
   811                              <1> .writeDone:
   812 0000148D 488B15(28000000)    <1>     mov rdx, qword [eofPtr] ;Now write out the EOF char to the file
   813 00001494 B901000000          <1>     mov ecx, 1
   814 00001499 0FB71D(3C000000)    <1>     movzx ebx, word [writeHdl]
   815 000014A0 B800400000          <1>     mov eax, 4000h
   816 000014A5 CD21                <1>     int 21h
   817 000014A7 0FB71D(3A000000)    <1>     movzx ebx, word [readHdl]
   818 000014AE B8003E0000          <1>     mov eax, 3E00h  ;Close the reading file!
   819 000014B3 CD21                <1>     int 21h
   820 000014B5 0FB71D(3C000000)    <1>     movzx ebx, word [writeHdl]  ;Get the write handle
   821 000014BC B8003E0000          <1>     mov eax, 3E00h  ;Close the temp file!
   822 000014C1 CD21                <1>     int 21h
   823 000014C3 F605(03000000)FF    <1>     test byte [newFileFlag], -1  ;If this is new file, skip this!
   824 000014CA 7522                <1>     jnz short .skipBkup
   825                              <1>     ;Now set the backup extension
   826 000014CC 488B3D(46010000)    <1>     mov rdi, qword [fileExtPtr]
   827 000014D3 B842414B00          <1>     mov eax, "BAK"
   828 000014D8 AB                  <1>     stosd
   829 000014D9 488D15(3E000000)    <1>     lea rdx, pathspec
   830 000014E0 488D3D(BE000000)    <1>     lea rdi, bkupfile
   831 000014E7 B800560000          <1>     mov eax, 5600h
   832 000014EC CD21                <1>     int 21h
   833                              <1> .skipBkup:
   834 000014EE B824242400          <1>     mov eax, "$$$"  ;Always set this as triple dollar as this is saved name!
   835 000014F3 488B3D(46010000)    <1>     mov rdi, qword [fileExtPtr]
   836 000014FA AB                  <1>     stosd
   837 000014FB 488D15(BE000000)    <1>     lea rdx, bkupfile
   838 00001502 488D3D(3E000000)    <1>     lea rdi, pathspec   ;Now name the temp file by the og name!
   839 00001509 B800560000          <1>     mov eax, 5600h
   840 0000150E CD21                <1>     int 21h
   841                              <1>     retToDOS errOk ;Let DOS do cleanup of memory allocations!
    94 00001510 B8004C0000          <2>  mov eax, 04C00h | %1
    95 00001515 CD21                <2>  int 21h
   842                              <1> 
   843                              <1> quit:
   844                              <1> ;Quits EDLIN, not saving work and deleting working file.
   845                              <1> ;--------------------------------------------
   846                              <1> ;Invoked by: Q
   847                              <1> ;--------------------------------------------
   848 00001517 803D(02000000)FF    <1>     cmp byte [roFlag], -1   ;If the flag is clear, dont prompt, just quit.
   849 0000151E 7426                <1>     je short .roQuit
   850 00001520 488D15(47020000)    <1>     lea rdx, exitQuit
   851 00001527 B800090000          <1>     mov eax, 0900h
   852 0000152C CD21                <1>     int 21h
   853 0000152E B8010C0000          <1>     mov eax, 0C01h  ;Flush input buffer and read a single char from stdin
   854 00001533 CD21                <1>     int 21h
   855 00001535 0FB6D8              <1>     movzx ebx, al
   856 00001538 81E3DF000000        <1>     and ebx, 0DFh    ;Convert to upper case
   857 0000153E 81FB59000000        <1>     cmp ebx, "Y"
   858 00001544 752E                <1>     jne printCRLF   ;Print CRLF and return via that return instruction
   859                              <1>     ;Delete the working file
   860                              <1> .roQuit:
   861 00001546 488B3D(46010000)    <1>     mov rdi, qword [fileExtPtr]
   862 0000154D B824242400          <1>     mov eax, "$$$"
   863 00001552 AB                  <1>     stosd
   864 00001553 488D15(BE000000)    <1>     lea rdx, wkfile
   865 0000155A B800410000          <1>     mov eax, 4100h  ;Delete the file
   866 0000155F CD21                <1>     int 21h
   867                              <1>     retToDOS errOk
    94 00001561 B8004C0000          <2>  mov eax, 04C00h | %1
    95 00001566 CD21                <2>  int 21h
    37                                  %include "./Source/edprn.asm"
     1                              <1> ;---------------------
     2                              <1> ; Print Routines here
     3                              <1> ;---------------------
     4                              <1> printString:
     5 00001568 B800090000          <1>     mov eax, 0900h
     6 0000156D CD21                <1>     int 21h
     7                              <1>     return
    13                              <2> %%_ret:
    14 0000156F C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
     8                              <1> ;----------------------------------------
     9                              <1> ; These functions print individual chars
    10                              <1> ;----------------------------------------
    11                              <1> printSpace:
    12 00001570 B020                <1>     mov al, SPC
    13 00001572 EB09                <1>     jmp short printChar
    14                              <1> printCRLF:
    15                              <1> ;Prints CRLF
    16 00001574 B00D                <1>     mov al, CR
    17 00001576 E802000000          <1>     call printChar
    18                              <1> printLF:
    19 0000157B B00A                <1>     mov al, LF
    20                              <1> printChar:
    21                              <1> ;Input: al = Char to print
    22 0000157D 50                  <1>     push rax    ;To preserve the rest of eax
    23 0000157E 52                  <1>     push rdx
    24 0000157F 0FB6D0              <1>     movzx edx, al
    25 00001582 B800020000          <1>     mov eax, 0200h
    26 00001587 CD21                <1>     int 21h
    27 00001589 5A                  <1>     pop rdx
    28 0000158A 58                  <1>     pop rax
    29                              <1>     return
    13                              <2> %%_ret:
    14 0000158B C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    30                              <1> 
    31                              <1> ;------------------------------------------------
    32                              <1> ; These functions are specialised print routines
    33                              <1> ;------------------------------------------------
    34                              <1> printLineNum:
    35                              <1> ;Prints the line number in bx
    36                              <1> ;Input: bx = Line number to print
    37 0000158C E8DFFFFFFF          <1>     call printSpace
    38 00001591 E816000000          <1>     call printNum
    39 00001596 B03A                <1>     mov al, ":"
    40 00001598 E8E0FFFFFF          <1>     call printChar
    41 0000159D 663B1D(1E000000)    <1>     cmp bx, word [curLineNum]
    42 000015A4 B020                <1>     mov al, SPC
    43 000015A6 75D5                <1>     jne printChar
    44 000015A8 B02A                <1>     mov al, "*"
    45 000015AA EBD1                <1>     jmp short printChar
    46                              <1> 
    47                              <1> printNum:
    48                              <1> ;Takes in bx a binary word and prints the ASCII value
    49                              <1> ; with leading blanks suppressed.
    50                              <1> ;Trashes eax, ecx and edx only
    51 000015AC 55                  <1>     push rbp
    52 000015AD 31ED                <1>     xor ebp, ebp    ;If not zero, stop suppressing leading zeros
    53 000015AF 0FB7D3              <1>     movzx edx, bx   ;Init with value in edx
    54                              <1> ;Do 10000's
    55 000015B2 B910270000          <1>     mov ecx, 10000
    56 000015B7 E827000000          <1>     call .doCompute
    57                              <1> ;Do 1000's
    58 000015BC B9E8030000          <1>     mov ecx, 1000
    59 000015C1 E81D000000          <1>     call .doCompute
    60                              <1> ;Do 100's
    61 000015C6 B964000000          <1>     mov ecx, 100
    62 000015CB E813000000          <1>     call .doCompute
    63                              <1> ;Do 10's
    64 000015D0 B90A000000          <1>     mov ecx, 10
    65 000015D5 E809000000          <1>     call .doCompute
    66                              <1> ;Do 1's, mild optimisation to avoid div move the remainder directly
    67 000015DA 89D0                <1>     mov eax, edx    ;Remainder in edx
    68 000015DC E808000000          <1>     call .printDig  ;Print the value in eax
    69                              <1> ;Exit
    70 000015E1 5D                  <1>     pop rbp
    71                              <1>     return
    13                              <2> %%_ret:
    14 000015E2 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    72                              <1> .doCompute:
    73                              <1> ;Input: ecx = Divisor for place value
    74                              <1> ;       edx = Remainder left to divide
    75 000015E3 89D0                <1>     mov eax, edx    ;Moves the prev. remainder into eax for dividing
    76 000015E5 31D2                <1>     xor edx, edx    
    77 000015E7 F7F1                <1>     div ecx         
    78                              <1> .printDig:
    79                              <1> ;Now print the digit in al, the quotient. edx has the remainder
    80 000015E9 85ED                <1>     test ebp, ebp
    81 000015EB 750A                <1>     jnz .pDigOk
    82 000015ED 85C0                <1>     test eax, eax   ;Is ebp = 0 and value to print 0? 
    83 000015EF 0F847BFFFFFF        <1>     jz printSpace   ;If so, print a space char (retz for no suppression)
    84 000015F5 FFCD                <1>     dec ebp         ;Else, now set ebp and print al
    85                              <1> .pDigOk:
    86 000015F7 0430                <1>     add al, "0"     ;Convert into an ASCII value
    87 000015F9 EB82                <1>     jmp short printChar   ;Return through printchar
    88                              <1> 
    89                              <1> printLine:
    90                              <1> ;Prints a single line
    91 000015FB BF01000000          <1>     mov edi, 1  ;Print a single line
    92                              <1> printLines:
    93                              <1> ;Prints many lines in EDLIN fashion. All regs trashed.
    94                              <1> ;Input:
    95                              <1> ;   bx = Line number offset to keep track of printing
    96                              <1> ;   rsi -> Ptr to start printing from
    97                              <1> ;   edi = Number of lines to print. Used as a word!
    98                              <1> ;Output:
    99                              <1> ;   bx = Last line number printed
   100 00001600 488B0D(28000000)    <1>     mov rcx, qword [eofPtr]
   101 00001607 4829F1              <1>     sub rcx, rsi
   102                              <1>     retz    ;If we are pointing to the eofPtr, nothing to print, return
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 0000160A 74(E2)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   103                              <1>     ;Now ecx = Number of chars to print!
   104                              <1> ;vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
   105                              <1> ; Get screen attribs here for controlled printing
   106 0000160C 89FA                <1>     mov edx, edi    ;Save number of lines to print in edx
   107                              <1> ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   108                              <1> .freshLine:
   109 0000160E 51                  <1>     push rcx
   110 0000160F 52                  <1>     push rdx
   111 00001610 E877FFFFFF          <1>     call printLineNum   ;Save ecx and edx as these are trashed!
   112 00001615 5A                  <1>     pop rdx
   113 00001616 59                  <1>     pop rcx
   114 00001617 488D3D(6B030000)    <1>     lea rdi, spareLine
   115                              <1> .goLine:
   116                              <1> ;Now we read the line into the spare buffer and echo each char one by one
   117                              <1> ;ecx = Number of chars to print
   118                              <1> ;edx = Number of lines we are printing
   119 0000161E AC                  <1>     lodsb
   120 0000161F 55                  <1>     push rbp
   121 00001620 488D2D(69040000)    <1>     lea rbp, spareLine + 254
   122 00001627 4839EF              <1>     cmp rdi, rbp
   123 0000162A 5D                  <1>     pop rbp
   124 0000162B 731B                <1>     jae .goDone
   125 0000162D 3C20                <1>     cmp al, SPC
   126 0000162F 7316                <1>     jae .store  ;If a normal char print it
   127                              <1>     ;Pick off LF, CR and TAB as special chars. Everything else is a ctrl char!
   128 00001631 3C0A                <1>     cmp al, LF 
   129 00001633 7412                <1>     je .store
   130 00001635 3C0D                <1>     cmp al, CR
   131 00001637 740E                <1>     je .store
   132 00001639 3C09                <1>     cmp al, TAB
   133 0000163B 740A                <1>     je .store
   134 0000163D B45E                <1>     mov ah, "^"
   135 0000163F 0C40                <1>     or al, 40h  ;Convert to UC
   136 00001641 86C4                <1>     xchg al, ah
   137 00001643 66AB                <1>     stosw   ;Store the pair of chars
   138 00001645 EB01                <1>     jmp short .goDone
   139                              <1> .store:
   140 00001647 AA                  <1>     stosb
   141                              <1> .goDone:
   142 00001648 3C0A                <1>     cmp al, LF  ;If not a line feed yet, keep going
   143 0000164A 7404                <1>     je .lfFnd   ;Else, we are done!
   144 0000164C FFC9                <1>     dec ecx     ;One less char to deal with
   145 0000164E 75CE                <1>     jnz .goLine
   146                              <1> .lfFnd:
   147 00001650 FFC9                <1>     dec ecx     ;Drop the final char on the line too!
   148 00001652 807FFF0A            <1>     cmp byte [rdi - 1], LF  ;Was the last char a LF?
   149 00001656 740C                <1>     je .okLine
   150 00001658 807FFF0D            <1>     cmp byte [rdi - 1], CR  ;Was the last char a CR?
   151 0000165C 7403                <1>     je .putLF
   152 0000165E B00D                <1>     mov al, CR
   153 00001660 AA                  <1>     stosb
   154                              <1> .putLF:
   155 00001661 B00A                <1>     mov al, LF
   156 00001663 AA                  <1>     stosb
   157                              <1> .okLine:
   158 00001664 C60700              <1>     mov byte [rdi], 0   ;Null terminate the line for printing
   159 00001667 E80C000000          <1>     call prnAsciiz  ;Print the chars in the buffer
   160 0000166C 67E308              <1>     jecxz .exit     ;If we have no more chars to print, exit!
   161 0000166F FFC3                <1>     inc ebx         ;Goto next line number
   162 00001671 FFCA                <1>     dec edx         ;One less line to print!
   163 00001673 7599                <1>     jnz .freshLine  ;If this is non-zero, keep going!
   164 00001675 FFCB                <1>     dec ebx         ;We done the last line
   165                              <1> .exit:
   166                              <1>     return
    13                              <2> %%_ret:
    14 00001677 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   167                              <1> 
   168                              <1> prnAsciiz:
   169 00001678 56                  <1>     push rsi
   170 00001679 488D35(6B030000)    <1>     lea rsi, spareLine  ;Now print the line we just made!
   171                              <1> .pcLp:
   172 00001680 AC                  <1>     lodsb
   173 00001681 84C0                <1>     test al, al
   174 00001683 7407                <1>     jz .pcExit
   175 00001685 E8F3FEFFFF          <1>     call printChar  ;Preserves dx
   176 0000168A EBF4                <1>     jmp short .pcLp
   177                              <1> .pcExit:
   178 0000168C 5E                  <1>     pop rsi
   179                              <1>     return
    13                              <2> %%_ret:
    14 0000168D C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    38                                  %include "./Source/ederr.asm"
     1                              <1> ;---------------------
     2                              <1> ; Error Routines here
     3                              <1> ;---------------------
     4                              <1> printLineNotFoundErr:
     5 0000168E 488D15(88020000)    <1>     lea rdx, badSearch
     6 00001695 EB10                <1>     jmp short printErr
     7                              <1> printMemErr:
     8 00001697 488D15(7B010000)    <1>     lea rdx, badMemFull
     9 0000169E EB07                <1>     jmp short printErr
    10                              <1> printComErr:
    11                              <1> ;JUMP to this procedure and it jumps back to
    12                              <1> ; the command loop resetting the stack!
    13 000016A0 488D15(58010000)    <1>     lea rdx, badInput
    14                              <1> printErr:
    15 000016A7 E8BCFEFFFF          <1>     call printString
    16 000016AC E95BEDFFFF          <1>     jmp getCommand
    17                              <1> 
    18                              <1> ;The below "Fail" units are a class of Edlin terminating functions
    19                              <1> badReadFail:
    20 000016B1 488D15(21020000)    <1>     lea rdx, badRead
    21 000016B8 E8ABFEFFFF          <1>     call printString
    22                              <1>     retToDOS errBadRead
    94 000016BD B8034C0000          <2>  mov eax, 04C00h | %1
    95 000016C2 CD21                <2>  int 21h
    23                              <1> 
    24                              <1> fullDiskFail:
    25 000016C4 488D15(01020000)    <1>     lea rdx, badDskFull ;Write disk full error, but return to prompt
    26 000016CB E898FEFFFF          <1>     call printString
    27                              <1>     retToDOS errDskFull
    94 000016D0 B8024C0000          <2>  mov eax, 04C00h | %1
    95 000016D5 CD21                <2>  int 21h
    28                              <1> 
    29                              <1> charDevFail:
    30 000016D7 488D15(8D000000)    <1>     lea rdx, badFindStr
    31 000016DE E885FEFFFF          <1>     call printString
    32                              <1>     retToDOS errCharDev
    94 000016E3 B8054C0000          <2>  mov eax, 04C00h | %1
    95 000016E8 CD21                <2>  int 21h
    39                                  Segment .data align=1 follows=.text 
    40                                  %include "./Data/eddata.asm"
     1                              <1> ;Initialised data goes here :)
     2                              <1> 
     3                              <1> ;The following three tables are connected. Don't jiggle!
     4                              <1> cmdLetterTable:
     5 00000000 0D3B41434445494C50- <1>     db CR,";ACDEILPMQRSTW"
     5 00000009 4D5152535457        <1>
     6                              <1>     cmdLetterTableL equ $ - cmdLetterTable
     7                              <1> cmdFcnTable:
     8 0000000F (300A)              <1>     dw editLine - cmdFcnTable
     9 00000011 (300A)              <1>     dw editLine - cmdFcnTable
    10 00000013 (0612)              <1>     dw appendLines - cmdFcnTable
    11 00000015 (5F0D)              <1>     dw copyLines - cmdFcnTable
    12 00000017 (970B)              <1>     dw deleteLines - cmdFcnTable
    13 00000019 (2614)              <1>     dw endEdit - cmdFcnTable
    14 0000001B (C90A)              <1>     dw insertLine - cmdFcnTable
    15 0000001D (3511)              <1>     dw listLines - cmdFcnTable
    16 0000001F (8611)              <1>     dw pageLines - cmdFcnTable
    17 00000021 (460D)              <1>     dw moveLines - cmdFcnTable
    18 00000023 (0815)              <1>     dw quit - cmdFcnTable
    19 00000025 (0C10)              <1>     dw replaceText - cmdFcnTable
    20 00000027 (670F)              <1>     dw searchText - cmdFcnTable
    21 00000029 (260C)              <1>     dw transferLines - cmdFcnTable
    22 0000002B (7C13)              <1>     dw writeLines - cmdFcnTable
    23                              <1> cmdRoTable:
    24                              <1> ;Byte set if we can do this command in RO mode
    25 0000002D 00                  <1>     db 0    ;Insert
    26 0000002E 00                  <1>     db 0    ;Insert
    27 0000002F FF                  <1>     db -1   ;Append
    28 00000030 00                  <1>     db 0    ;Copy
    29 00000031 00                  <1>     db 0    ;Delete
    30 00000032 00                  <1>     db 0    ;End (save changes)
    31 00000033 00                  <1>     db 0    ;Insert
    32 00000034 FF                  <1>     db -1   ;List
    33 00000035 FF                  <1>     db -1   ;Page
    34 00000036 00                  <1>     db 0    ;Move
    35 00000037 FF                  <1>     db -1   ;Quit (no save)
    36 00000038 00                  <1>     db 0    ;Replace
    37 00000039 FF                  <1>     db -1   ;Search
    38 0000003A 00                  <1>     db 0    ;Transfer 
    39 0000003B FF                  <1>     db -1   ;Write
    41                                  %include "./Data/edmsg.asm"
     1                              <1> ;Edlin Strings are in this file
     2 0000003C 4E65772066696C650D- <1> newStr  db "New file",CR,LF,"$"
     2 00000045 0A24                <1>
     3 00000047 456E64206F6620696E- <1> eofStr  db "End of input file",CR,LF,"$"    ;When EOF occurs
     3 00000050 7075742066696C650D- <1>
     3 00000059 0A24                <1>
     4 0000005B 496E76616C69642044- <1> badVerStr   db "Invalid DOS Version",CR,LF,"$"
     4 00000064 4F532056657273696F- <1>
     4 0000006D 6E0D0A24            <1>
     5 00000071 496E76616C69642044- <1> badDrvStr   db "Invalid Drive or filename",CR,LF,"$"
     5 0000007A 72697665206F722066- <1>
     5 00000083 696C656E616D650D0A- <1>
     5 0000008C 24                  <1>
     6 0000008D 46696C65206E6F7420- <1> badFindStr  db "File not found",CR,LF,"$"
     6 00000096 666F756E640D0A24    <1>
     7 0000009E 46696C65206E616D65- <1> badNameStr  db "File name must be specified",CR,LF,"$"
     7 000000A7 206D75737420626520- <1>
     7 000000B0 737065636966696564- <1>
     7 000000B9 0D0A24              <1>
     8 000000BC 43616E6E6F74206372- <1> badCreatStr db "Cannot create specified file",CR,LF,"$"
     8 000000C5 656174652073706563- <1>
     8 000000CE 69666965642066696C- <1>
     8 000000D7 650D0A24            <1>
     9 000000DB 43616E6E6F74206F70- <1> badOpenStr  db "Cannot open specified file",CR,LF,"$"
     9 000000E4 656E20737065636966- <1>
     9 000000ED 6965642066696C650D- <1>
     9 000000F6 0A24                <1>
    10 000000F8 43616E6E6F74207061- <1> badFileStr  db "Cannot parse sepcified filespec",CR,LF,"$"
    10 00000101 727365207365706369- <1>
    10 0000010A 666965642066696C65- <1>
    10 00000113 737065630D0A24      <1>
    11 0000011A 416363657373206465- <1> badBackDel  db "Access denied - Backup file not deleted",CR,LF,"$"
    11 00000123 6E696564202D204261- <1>
    11 0000012C 636B75702066696C65- <1>
    11 00000135 206E6F742064656C65- <1>
    11 0000013E 7465640D0A24        <1>
    12 00000144 496E76616C69642050- <1> badParm     db "Invalid Parameter",CR,LF,"$"
    12 0000014D 6172616D657465720D- <1>
    12 00000156 0A24                <1>
    13 00000158 456E74727920657272- <1> badInput    db "Entry error",CR,LF,"$"
    13 00000161 6F720D0A24          <1>
    14 00000166 5265616C6C6F636174- <1> badRealloc  db "Reallocation error",CR,LF,"$"
    14 0000016F 696F6E206572726F72- <1>
    14 00000178 0D0A24              <1>
    15 0000017B 0D0A496E7375666669- <1> badMemFull  db CR,LF,"Insufficient memory",CR,LF,"$"
    15 00000184 6369656E74206D656D- <1>
    15 0000018D 6F72790D0A24        <1>
    16 00000193 4E6F7420656E6F7567- <1> badMergeStr db "Not enough room to merge the entire file",CR,LF,"$"
    16 0000019C 6820726F6F6D20746F- <1>
    16 000001A5 206D65726765207468- <1>
    16 000001AE 6520656E7469726520- <1>
    16 000001B7 66696C650D0A24      <1>
    17 000001BE 43616E6E6F74206564- <1> badFileExt  db "Cannot edit .BAK file--rename file",CR,LF,"$"
    17 000001C7 6974202E42414B2066- <1>
    17 000001D0 696C652D2D72656E61- <1>
    17 000001D9 6D652066696C650D0A- <1>
    17 000001E2 24                  <1>
    18 000001E3 496E76616C6964206F- <1> badROcmd    db "Invalid operation: R/O file",CR,LF,"$"
    18 000001EC 7065726174696F6E3A- <1>
    18 000001F5 20522F4F2066696C65- <1>
    18 000001FE 0D0A24              <1>
    19 00000201 4469736B2066756C6C- <1> badDskFull  db "Disk full-- write not completed$"
    19 0000020A 2D2D20777269746520- <1>
    19 00000213 6E6F7420636F6D706C- <1>
    19 0000021C 6574656424          <1>
    20 00000221 426164207265616420- <1> badRead     db "Bad read of input file. Aborting...",CR,LF,"$"
    20 0000022A 6F6620696E70757420- <1>
    20 00000233 66696C652E2041626F- <1>
    20 0000023C 7274696E672E2E2E0D- <1>
    20 00000245 0A24                <1>
    21 00000247 41626F727420656469- <1> exitQuit    db "Abort edit (Y/N)? $"
    21 00000250 742028592F4E293F20- <1>
    21 00000259 24                  <1>
    22 0000025A 4F2E4B2E3F2024      <1> okString    db "O.K.? $"
    23 00000261 4D7573742073706563- <1> badDestStr  db "Must specify destination line number",CR,LF,"$"
    23 0000026A 696679206465737469- <1>
    23 00000273 6E6174696F6E206C69- <1>
    23 0000027C 6E65206E756D626572- <1>
    23 00000285 0D0A24              <1>
    24 00000288 4E6F7420666F756E64- <1> badSearch   db "Not found",CR,LF,"$"
    24 00000291 0D0A24              <1>
    25 00000294 4C696E6520746F6F20- <1> badLineLen  db "Line too long",CR,LF,"$"
    25 0000029D 6C6F6E670D0A24      <1>
    42                                  Segment .bss align=1 follows=.data nobits
    43                                  bssStart:
    44                                  %include "./Data/edbss.asm"
     1                              <1> ;WE SET ALL VARS TO 0 ON STARTUP!
     2                              <1> 
     3 00000000 ??                  <1> pathSep     db ?    ;Default \, Alternative /
     4 00000001 ??                  <1> switchChar  db ?    ;Default /, Alternative -
     5 00000002 ??                  <1> roFlag      db ?    ;Flag is set if file is read-only. Cannot edit the file.
     6 00000003 ??                  <1> newFileFlag db ?    ;Flag indicating the file being made is new (when set, above flag meaningless)
     7 00000004 ??                  <1> noEofChar   db ?    ;Flag is set if we are not to check for ^Z chars found in the file
     8 00000005 ??                  <1> eofReached  db ?    ;When we reach EOF for file on disk, set to -1, else 0
     9                              <1> 
    10                              <1> ;Memory Related variables
    11 00000006 ????????            <1> arenaSize   dd ?    ;Size of the arena in bytes 
    12 0000000A ????????            <1> freeCnt     dd ?    ;Count of 1/4 of the arena in bytes (for write)
    13 0000000E ????????????????    <1> memPtr      dq ?    ;Ptr to the memory arena given by DOS
    14 00000016 ????????????????    <1> fillPtr     dq ?    ;Ptr to 3/4 of the arena in bytes (for append)
    15                              <1> 
    16                              <1> ;Editor state vars!
    17 0000001E ????                <1> curLineNum  dw ?    ;Word value for the current line number (1 based)
    18 00000020 ????????????????    <1> curLinePtr  dq ?    ;Pointer to the current line
    19 00000028 ????????????????    <1> eofPtr      dq ?    ;Pointer to the EOF char in the buffer
    20 00000030 ????????????????    <1> endOfArena  dq ?    ;Ptr to the last available byte in the arena
    21                              <1> 
    22 00000038 ??                  <1> modFlag     db ?    ;Flag set to indicate the file was modified
    23                              <1> ;Backup is only deleted on exit or write, to make space for temp file.
    24 00000039 ??                  <1> bkupDel     db ?    ;Flag to indicate that the backup was deleted
    25                              <1> 
    26                              <1> ;Don't jiggle these symbols, need dword to be together for -1
    27 0000003A ????                <1> readHdl     dw ?    ;Contain the file handle for the open file
    28 0000003C ????                <1> writeHdl    dw ?    ;Handle to the temporary file
    29                              <1> 
    30 0000003E <res 80h>           <1> pathspec    db 128 dup (?)  ;Space for the 128 byte buffer for full filename
    31                              <1> wkfile:                     ;Ptr to below path for "working" file
    32 000000BE <res 80h>           <1> bkupfile    db 128 dup (?)  ;Pathspec for backup file 
    33                              <1> 
    34                              <1> tmpNamePtr:         ;Ptr to the filename in the commandtail
    35 0000013E ????????????????    <1> fileNamePtr dq ?    ;Ptr to the name portion of filespec
    36                              <1> tmpNamePtr2:        ;Ptr to the end of the command in the commandtail
    37 00000146 ????????????????    <1> fileExtPtr  dq ?    ;Ptr to the extension of the file we are editing
    38                              <1> ;The above pointers point past the dot or pathseperator
    39                              <1> ;Both file*ptr's point to elements on WKFILE not pathspec
    40                              <1> 
    41                              <1> ;Command line variables
    42 0000014E <res 82h>           <1> cmdLine     db halfLine_size dup (?)
    43                              <1> ;Arguments for parsing
    44 000001D0 ????????????????    <1> charPtr     dq ?    ;Ptr to char for continuing processing
    45 000001D8 ??                  <1> argCnt      db ?    ;Count of arguments in parsed command line
    46                              <1> ;Arguments are converted to signed words where appropriate
    47                              <1> ; and parsed into here in the order they are encountered in.
    48                              <1> ;
    49                              <1> ;Any arguments which mean 0 wrt line numbers means current line
    50                              <1> argTbl:
    51 000001D9 ????                <1> arg1        dw ?
    52 000001DB ????                <1> arg2        dw ?
    53 000001DD ????                <1> arg3        dw ?
    54 000001DF ????                <1> arg4        dw ?
    55 000001E1 ??                  <1> qmarkSet    db ?    ;Set if question mark encountered
    56 000001E2 <res 82h>           <1> argString   db halfLine_size dup (?)    ;Used by search and replace only
    57                              <1> 
    58 00000264 ??                  <1> noAppendErr db ?    ;Special init var, prevents append errors for initial load
    59                              <1> 
    60                              <1> ;The workline gets preloaded with the original line before editing
    61 00000265 <res 102h>          <1> workLine    db 258 dup (?)  ;Line in which all editing takes place
    62 00000367 ????????            <1> workLen     dd ?            ;Line length before edit
    63 0000036B <res 102h>          <1> spareLine   db 258 dup (?)  ;Spare editing line
    64                              <1> ;Transfer Vars
    65 0000046D <res 80h>           <1> xfrName     db 128 dup (?)  ;Transfer name buffer
    66 000004ED ????                <1> xfrHdl      dw ?
    67                              <1> ;Block vars
    68 000004EF ??                  <1> movCpFlg    db ?    ;Set if move, clear if copy
    69 000004F0 ????????????????    <1> blkPtrSrc   dq ?    ;Ptr to the line which starts the copy
    70 000004F8 ????????????????    <1> blkPtrEnd   dq ?    ;Ptr to the line after the range we will copy
    71 00000500 ????????????????    <1> cpyPtrDest  dq ?    ;Ptr to the line we will be copying to
    72 00000508 ????????            <1> blkSize     dd ?    ;This is the size of the unit to move (cpySize)
    73 0000050C ????????            <1> copySize    dd ?    ;This is the number of bytes we will copy (cpyLen)
    74                              <1> ;Search/Replace vars
    75 00000510 ??                  <1> srchMode    db ?    ;Set = Find from current line + 1, clear = line 1
    76                              <1> ;Find common vars
    77 00000511 ??                  <1> findMod     db ?    ;Set = Search, Clear = Replace
    78 00000512 ??                  <1> keepOld     db ?    ;Set = Keep old data. Clear = Clear old data (search/rep)
    79 00000513 ????                <1> fndLenOld   dw ?    ;Length of find string 
    80 00000515 ????                <1> fndLenNew   dw ?    ;New string length! 
    81 00000517 ????????????????    <1> fndStrPtr   dq ?    ;[DOS LSTFND] Ptr to the start of the last found string
    82 0000051F ????????????????    <1> fndLinePtr  dq ?    ;[DOS NUMPOS] Ptr to the start of the last found line
    83 00000527 ????                <1> fndLineNum  dw ?    ;[DOS LSTNUM] Line number of the last found line
    84 00000529 ????????            <1> fndSrchLen  dd ?    ;Number of bytes we are searching through!
    85 0000052D <res 81h>           <1> fndString1  db 81h dup (?)  ;1 for string length prefix + 128 for the string
    86 000005AE <res 81h>           <1> fndString2  db 81h dup (?)
    45                                  bssLen equ ($ - bssStart)
    46                                  Segment .stack align=16 follows=.bss nobits
    47                                  ;Use a 200 QWORD stack
    48 00000000 <res 640h>                  dq 200 dup (?)
    49                                  stackTop:
    50                                  endOfProgram:   ;Deallocate from here
    50          ------------------       info: assembly required 1+5+2 passes

